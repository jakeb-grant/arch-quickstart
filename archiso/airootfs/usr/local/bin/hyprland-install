#!/usr/bin/env bash
#
# Hyprland Arch Installer
# A beautiful TUI installer for a custom Hyprland desktop
#

set -eEo pipefail

# Trap errors and show what failed
trap 'echo ""; echo "ERROR: Command failed at line $LINENO: $BASH_COMMAND"; echo "Press Enter to exit..."; read' ERR

# Colors for gum
export GUM_CHOOSE_CURSOR_FOREGROUND="#89b4fa"
export GUM_CHOOSE_SELECTED_FOREGROUND="#a6e3a1"
export GUM_INPUT_CURSOR_FOREGROUND="#89b4fa"
export GUM_INPUT_PROMPT_FOREGROUND="#cba6f7"
export GUM_CONFIRM_PROMPT_FOREGROUND="#f9e2af"
export GUM_SPIN_SPINNER_FOREGROUND="#89b4fa"

# Package list location
PACKAGES_FILE="/root/target-packages.x86_64"
CONFIG_FILE="/root/install.conf"

# Load configuration defaults
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Fallback defaults if config not found
DEFAULT_USERNAME="${DEFAULT_USERNAME:-user}"
DEFAULT_TIMEZONE="${DEFAULT_TIMEZONE:-America/Denver}"
DEFAULT_LOCALE="${DEFAULT_LOCALE:-en_US.UTF-8}"
DEFAULT_KEYMAP="${DEFAULT_KEYMAP:-us}"
DEFAULT_SHELL="${DEFAULT_SHELL:-/bin/zsh}"
GIT_USER_NAME="${GIT_USER_NAME:-}"
GIT_USER_EMAIL="${GIT_USER_EMAIL:-}"

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

die() {
    gum style --foreground="#f38ba8" --bold "ERROR: $1"
    exit 1
}

info() {
    gum style --foreground="#89b4fa" "$1"
}

success() {
    gum style --foreground="#a6e3a1" "$1"
}

warn() {
    gum style --foreground="#f9e2af" "$1"
}

header() {
    clear
    gum style \
        --border double \
        --border-foreground="#cba6f7" \
        --padding "1 2" \
        --margin "1" \
        --align center \
        --bold \
        "Hyprland Arch Installer"
    echo
}

# -----------------------------------------------------------------------------
# Network Check
# -----------------------------------------------------------------------------

check_network() {
    header
    info "Checking network connectivity..."
    echo

    # Test internet connectivity
    if ping -c 1 -W 3 archlinux.org &>/dev/null; then
        success "Network connected!"
        sleep 1
        return 0
    fi

    warn "No internet connection detected."
    echo

    # Check if WiFi interfaces exist
    if [[ -d /sys/class/net ]] && ls /sys/class/net | grep -qE '^wl'; then
        if gum confirm "Would you like to connect to WiFi?"; then
            connect_wifi
        else
            die "Internet connection required for installation."
        fi
    else
        die "No network connection. Please connect via ethernet and restart."
    fi
}

connect_wifi() {
    header
    info "Scanning for WiFi networks..."
    echo

    # Make sure NetworkManager is running
    systemctl start NetworkManager 2>/dev/null || true
    sleep 2

    # Get list of WiFi networks
    local networks
    networks=$(nmcli -t -f SSID dev wifi list 2>/dev/null | grep -v '^$' | sort -u)

    if [[ -z "$networks" ]]; then
        warn "No WiFi networks found. Rescanning..."
        nmcli dev wifi rescan 2>/dev/null || true
        sleep 3
        networks=$(nmcli -t -f SSID dev wifi list 2>/dev/null | grep -v '^$' | sort -u)
    fi

    if [[ -z "$networks" ]]; then
        die "No WiFi networks found!"
    fi

    info "Select WiFi network:"
    local ssid
    ssid=$(echo "$networks" | gum choose --height=15)

    if [[ -z "$ssid" ]]; then
        die "No network selected!"
    fi

    info "Enter password for '$ssid':"
    local wifi_password
    wifi_password=$(gum input --password --placeholder "WiFi password")

    info "Connecting to '$ssid'..."
    if nmcli dev wifi connect "$ssid" password "$wifi_password" 2>&1; then
        sleep 2
        if ping -c 1 -W 3 archlinux.org &>/dev/null; then
            success "Connected to WiFi!"
            sleep 1
            return 0
        fi
    fi

    warn "Failed to connect. Try again?"
    if gum confirm; then
        connect_wifi
    else
        die "Internet connection required for installation."
    fi
}

# -----------------------------------------------------------------------------
# Welcome Screen
# -----------------------------------------------------------------------------

welcome() {
    header
    gum style \
        --padding "1 2" \
        --margin "0 2" \
        "Welcome to the Hyprland Arch Linux installer!" \
        "" \
        "This will install a clean Arch Linux system with:" \
        "  • Hyprland compositor" \
        "  • SDDM display manager" \
        "  • Waybar, Walker, Ghostty" \
        "  • Firefox, Nautilus" \
        "  • Pipewire audio" \
        "" \
        "The installation will:" \
        "  • Erase the selected disk completely" \
        "  • Create GPT partitions (EFI + BTRFS root)" \
        "  • Install all packages and configure the system"

    echo
    if ! gum confirm "Ready to proceed?"; then
        gum style --foreground="#f9e2af" "Installation cancelled."
        exit 0
    fi
}

# -----------------------------------------------------------------------------
# Disk Selection
# -----------------------------------------------------------------------------

select_disk() {
    header
    info "Scanning for available disks..."
    echo

    # Get list of disks (exclude loop devices and rom)
    mapfile -t disks < <(lsblk -dpno NAME,SIZE,MODEL | grep -E '^/dev/(sd|nvme|vd)' | sort)

    if [[ ${#disks[@]} -eq 0 ]]; then
        die "No suitable disks found!"
    fi

    gum style --foreground="#cba6f7" "Select the target disk for installation:"
    echo

    DISK=$(printf '%s\n' "${disks[@]}" | gum choose --height=10)
    DISK=$(echo "$DISK" | awk '{print $1}')

    if [[ -z "$DISK" ]]; then
        die "No disk selected!"
    fi

    echo
    warn "WARNING: All data on $DISK will be destroyed!"
    echo

    lsblk "$DISK"
    echo

    if ! gum confirm --default=false "Are you sure you want to erase $DISK?"; then
        die "Installation cancelled by user."
    fi

    # Double confirmation for safety
    echo
    gum style --foreground="#f38ba8" "Type 'yes' to confirm disk erasure:"
    CONFIRM=$(gum input --placeholder "Type 'yes' to confirm")

    if [[ "$CONFIRM" != "yes" ]]; then
        die "Installation cancelled."
    fi
}

# -----------------------------------------------------------------------------
# User Configuration
# -----------------------------------------------------------------------------

configure_user() {
    header
    gum style --foreground="#cba6f7" "Configure your system:"
    echo

    # Hostname - select from predefined options
    info "Select machine type:"
    if [[ ${#DEFAULT_HOSTNAME_OPTIONS[@]} -gt 0 ]]; then
        HOSTNAME=$(printf '%s\n' "${DEFAULT_HOSTNAME_OPTIONS[@]}" | gum choose)
    else
        HOSTNAME=$(gum input --placeholder "archlinux" --value "archlinux")
    fi
    HOSTNAME=${HOSTNAME:-archlinux}

    echo

    # Username - pre-filled with default
    info "Enter username:"
    USERNAME=$(gum input --placeholder "$DEFAULT_USERNAME" --value "$DEFAULT_USERNAME")
    USERNAME=${USERNAME:-$DEFAULT_USERNAME}

    if [[ -z "$USERNAME" ]]; then
        die "Username cannot be empty!"
    fi

    echo

    # Password - must be entered
    info "Enter password for $USERNAME:"
    PASSWORD=$(gum input --password --placeholder "Password")

    if [[ -z "$PASSWORD" ]]; then
        die "Password cannot be empty!"
    fi

    info "Confirm password:"
    PASSWORD_CONFIRM=$(gum input --password --placeholder "Confirm password")

    if [[ "$PASSWORD" != "$PASSWORD_CONFIRM" ]]; then
        die "Passwords do not match!"
    fi

    echo

    # Disk encryption
    ENCRYPT_DISK="no"
    ENCRYPT_PASSWORD=""
    info "Disk encryption (LUKS):"
    if gum confirm --default=false "Enable full disk encryption?"; then
        ENCRYPT_DISK="yes"
        if gum confirm "Use the same password for encryption?"; then
            ENCRYPT_PASSWORD="$PASSWORD"
        else
            info "Enter encryption passphrase:"
            ENCRYPT_PASSWORD=$(gum input --password --placeholder "Encryption passphrase")
            if [[ -z "$ENCRYPT_PASSWORD" ]]; then
                die "Encryption passphrase cannot be empty!"
            fi
            info "Confirm encryption passphrase:"
            local encrypt_confirm
            encrypt_confirm=$(gum input --password --placeholder "Confirm passphrase")
            if [[ "$ENCRYPT_PASSWORD" != "$encrypt_confirm" ]]; then
                die "Encryption passphrases do not match!"
            fi
        fi
    fi

    echo

    # Timezone - pre-filled with default, option to change
    info "Timezone (default: $DEFAULT_TIMEZONE):"
    if gum confirm "Use default timezone ($DEFAULT_TIMEZONE)?"; then
        TIMEZONE="$DEFAULT_TIMEZONE"
    else
        TIMEZONE=$(find /usr/share/zoneinfo -type f | sed 's|/usr/share/zoneinfo/||' | grep -E '^(America|Europe|Asia|Australia|Pacific)' | sort | gum filter --height=15 --placeholder="Search timezone..." --value="America/")
        TIMEZONE=${TIMEZONE:-$DEFAULT_TIMEZONE}
    fi

    echo

    # Git configuration - pre-filled with defaults, editable
    info "Git configuration:"
    info "  Git username:"
    GIT_USER_NAME=$(gum input --placeholder "Git username" --value "$GIT_USER_NAME")

    info "  Git email:"
    GIT_USER_EMAIL=$(gum input --placeholder "Git email" --value "$GIT_USER_EMAIL")

    echo
    success "Configuration summary:"
    echo "  Machine:    $HOSTNAME"
    echo "  Username:   $USERNAME"
    echo "  Encryption: $ENCRYPT_DISK"
    echo "  Timezone:   $TIMEZONE"
    echo "  Locale:     $DEFAULT_LOCALE"
    echo "  Keymap:     $DEFAULT_KEYMAP"
    if [[ -n "$GIT_USER_NAME" ]]; then
        echo "  Git user:   $GIT_USER_NAME <$GIT_USER_EMAIL>"
    fi
    echo

    if ! gum confirm "Proceed with these settings?"; then
        configure_user
    fi
}

# -----------------------------------------------------------------------------
# Partitioning
# -----------------------------------------------------------------------------

partition_disk() {
    header
    info "Partitioning $DISK..."
    echo

    gum spin --spinner dot --title "Wiping disk..." -- \
        wipefs -af "$DISK"

    gum spin --spinner dot --title "Creating partition table..." -- \
        parted -s "$DISK" mklabel gpt

    gum spin --spinner dot --title "Creating EFI partition (512MB)..." -- \
        parted -s "$DISK" mkpart primary fat32 1MiB 513MiB

    gum spin --spinner dot --title "Setting EFI flags..." -- \
        parted -s "$DISK" set 1 esp on

    gum spin --spinner dot --title "Creating root partition..." -- \
        parted -s "$DISK" mkpart primary btrfs 513MiB 100%

    sleep 1  # Wait for kernel to update partition table

    # Determine partition names (handle nvme vs sd naming)
    if [[ "$DISK" == *"nvme"* ]]; then
        EFI_PART="${DISK}p1"
        ROOT_PART="${DISK}p2"
    else
        EFI_PART="${DISK}1"
        ROOT_PART="${DISK}2"
    fi

    success "Partitioning complete!"
    echo
    lsblk "$DISK"
    sleep 2
}

# -----------------------------------------------------------------------------
# Formatting
# -----------------------------------------------------------------------------

format_partitions() {
    header
    info "Formatting partitions..."
    echo

    info "Formatting EFI partition (FAT32)..."
    mkfs.fat -F32 "$EFI_PART"

    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        info "Setting up LUKS encryption..."
        echo -n "$ENCRYPT_PASSWORD" | cryptsetup luksFormat --type luks2 "$ROOT_PART" -

        info "Opening encrypted container..."
        echo -n "$ENCRYPT_PASSWORD" | cryptsetup open "$ROOT_PART" cryptroot -

        # Store the mapper device for later use
        CRYPT_DEVICE="/dev/mapper/cryptroot"

        info "Formatting encrypted partition (BTRFS)..."
        mkfs.btrfs -f "$CRYPT_DEVICE"
    else
        info "Formatting root partition (BTRFS)..."
        mkfs.btrfs -f "$ROOT_PART"
        CRYPT_DEVICE=""
    fi

    success "Formatting complete!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Mount Partitions
# -----------------------------------------------------------------------------

mount_partitions() {
    header
    info "Mounting partitions..."
    echo

    # Determine which device to mount (encrypted or plain)
    local mount_device
    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        mount_device="$CRYPT_DEVICE"
    else
        mount_device="$ROOT_PART"
    fi

    # Mount root
    mount "$mount_device" /mnt

    # Create BTRFS subvolumes
    info "Creating BTRFS subvolumes..."
    btrfs subvolume create /mnt/@
    btrfs subvolume create /mnt/@home
    btrfs subvolume create /mnt/@snapshots
    btrfs subvolume create /mnt/@var_log
    btrfs subvolume create /mnt/@swap

    # Unmount and remount with subvolumes
    umount /mnt

    mount -o noatime,compress=zstd,space_cache=v2,subvol=@ "$mount_device" /mnt

    mkdir -p /mnt/{boot/efi,home,.snapshots,var/log,swap}

    mount -o noatime,compress=zstd,space_cache=v2,subvol=@home "$mount_device" /mnt/home
    mount -o noatime,compress=zstd,space_cache=v2,subvol=@snapshots "$mount_device" /mnt/.snapshots
    mount -o noatime,compress=zstd,space_cache=v2,subvol=@var_log "$mount_device" /mnt/var/log
    # Swap subvolume: no compression, no copy-on-write
    mount -o noatime,nodatacow,subvol=@swap "$mount_device" /mnt/swap

    mount "$EFI_PART" /mnt/boot/efi

    success "Partitions mounted!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install Base System
# -----------------------------------------------------------------------------

install_base() {
    header
    info "Installing base system..."
    echo

    # Initialize pacman keyring
    info "Initializing pacman keyring..."
    pacman-key --init
    pacman-key --populate archlinux

    # Sync package databases
    info "Syncing package databases..."
    pacman -Sy

    # Pre-configure locale in target before package install
    # Some packages check locale during installation
    info "Pre-configuring locale..."
    mkdir -p /mnt/etc
    echo "$DEFAULT_LOCALE UTF-8" > /mnt/etc/locale.gen
    echo "LANG=$DEFAULT_LOCALE" > /mnt/etc/locale.conf
    echo "KEYMAP=$DEFAULT_KEYMAP" > /mnt/etc/vconsole.conf

    # Read packages from file
    if [[ -f "$PACKAGES_FILE" ]]; then
        mapfile -t packages < <(grep -v '^#' "$PACKAGES_FILE" | grep -v '^$')
    else
        # Fallback to essential packages if file not found
        packages=(base linux linux-firmware grub efibootmgr networkmanager)
        warn "Package list not found, installing minimal system..."
    fi

    info "Installing ${#packages[@]} packages..."
    info "This will take several minutes..."
    echo

    # Install packages with pacstrap
    pacstrap -K /mnt "${packages[@]}"

    # Verify installation succeeded
    if [[ ! -x /mnt/usr/bin/ln ]]; then
        die "Base system installation failed - coreutils not found!"
    fi

    success "Base system installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Configure System
# -----------------------------------------------------------------------------

configure_system() {
    header
    info "Configuring system..."
    echo

    # Generate fstab
    info "  Generating fstab..."
    genfstab -U /mnt >> /mnt/etc/fstab

    # Timezone
    info "  Setting timezone..."
    arch-chroot /mnt ln -sf "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
    arch-chroot /mnt hwclock --systohc

    # Generate locale (config was set before pacstrap)
    info "  Generating locale..."
    arch-chroot /mnt locale-gen

    # Hostname
    info "  Setting hostname..."
    echo "$HOSTNAME" > /mnt/etc/hostname
    cat > /mnt/etc/hosts << EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   $HOSTNAME.localdomain $HOSTNAME
EOF

    # Create user
    info "  Creating user $USERNAME..."
    arch-chroot /mnt useradd -m -G wheel -s "$DEFAULT_SHELL" "$USERNAME"
    echo "$USERNAME:$PASSWORD" | arch-chroot /mnt chpasswd

    # Copy custom Hyprland config to user's home
    info "  Installing Hyprland config..."
    mkdir -p "/mnt/home/$USERNAME/.config/hypr"
    cp /etc/skel/.config/hypr/hyprland.conf "/mnt/home/$USERNAME/.config/hypr/"
    arch-chroot /mnt chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.config"

    # Configure git for user
    if [[ -n "$GIT_USER_NAME" && -n "$GIT_USER_EMAIL" ]]; then
        info "  Configuring git..."
        arch-chroot /mnt sudo -u "$USERNAME" git config --global user.name "$GIT_USER_NAME"
        arch-chroot /mnt sudo -u "$USERNAME" git config --global user.email "$GIT_USER_EMAIL"
        arch-chroot /mnt sudo -u "$USERNAME" git config --global init.defaultBranch main
    fi

    # Enable sudo for wheel group
    info "  Configuring sudo..."
    sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /mnt/etc/sudoers

    # Configure encryption if enabled
    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        info "  Configuring disk encryption..."

        # Get UUID of the encrypted partition
        local crypt_uuid
        crypt_uuid=$(blkid -s UUID -o value "$ROOT_PART")

        # Add encrypt hook to mkinitcpio
        sed -i 's/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block encrypt filesystems fsck)/' /mnt/etc/mkinitcpio.conf

        # Configure GRUB for encrypted root
        sed -i "s|^GRUB_CMDLINE_LINUX=\"\"|GRUB_CMDLINE_LINUX=\"cryptdevice=UUID=$crypt_uuid:cryptroot root=/dev/mapper/cryptroot\"|" /mnt/etc/default/grub

        # Enable GRUB cryptodisk support
        echo "GRUB_ENABLE_CRYPTODISK=y" >> /mnt/etc/default/grub

        # Regenerate initramfs
        info "  Regenerating initramfs..."
        arch-chroot /mnt mkinitcpio -P
    fi

    # Install bootloader
    info "  Installing GRUB bootloader..."
    arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB
    arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg

    # Enable services
    info "  Enabling services..."
    arch-chroot /mnt systemctl enable NetworkManager
    arch-chroot /mnt systemctl enable sddm

    # Copy setup scripts to installed system
    info "  Installing setup scripts..."
    for script in nvidia-setup intel-setup amd-setup bluetooth-setup printer-setup firewall-setup dotfiles-setup; do
        if [[ -f "/usr/local/bin/$script" ]]; then
            cp "/usr/local/bin/$script" "/mnt/usr/local/bin/"
            chmod +x "/mnt/usr/local/bin/$script"
        fi
    done

    success "System configured!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Configure Swap
# -----------------------------------------------------------------------------

configure_swap() {
    header
    info "Configuring swap file..."
    echo

    # Get total RAM in MB
    local ram_mb
    ram_mb=$(free -m | awk '/^Mem:/{print $2}')

    # Calculate swap size based on RAM (for hibernate support, match RAM)
    # Best practices:
    #   RAM <= 2GB:  2x RAM
    #   RAM 2-8GB:   Equal to RAM
    #   RAM > 8GB:   Equal to RAM (cap at 16GB for practicality)
    local swap_mb
    if [[ $ram_mb -le 2048 ]]; then
        swap_mb=$((ram_mb * 2))
    elif [[ $ram_mb -gt 16384 ]]; then
        swap_mb=16384  # Cap at 16GB
    else
        swap_mb=$ram_mb
    fi

    local swap_gb=$((swap_mb / 1024))
    info "Detected RAM: ${ram_mb}MB"
    info "Creating swap file: ${swap_gb}GB (${swap_mb}MB)"

    # Create swap file with proper attributes for BTRFS
    # The @swap subvolume is already mounted with nodatacow
    info "  Creating swap file (this may take a moment)..."

    # Use truncate for instant allocation, then chattr for safety
    truncate -s 0 /mnt/swap/swapfile
    chattr +C /mnt/swap/swapfile  # Disable copy-on-write

    # Allocate the actual space
    dd if=/dev/zero of=/mnt/swap/swapfile bs=1M count="$swap_mb" status=progress

    # Set permissions (must be 600)
    chmod 600 /mnt/swap/swapfile

    # Format as swap
    info "  Formatting swap file..."
    mkswap /mnt/swap/swapfile

    # Add to fstab
    info "  Adding swap to fstab..."
    echo "/swap/swapfile none swap defaults 0 0" >> /mnt/etc/fstab

    success "Swap file configured! (${swap_gb}GB)"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install AUR Packages
# -----------------------------------------------------------------------------

install_aur_packages() {
    header
    info "Installing AUR packages (Walker launcher)..."
    echo

    # Use user's home directory (guaranteed to exist after useradd -m)
    local script_path="/mnt/home/$USERNAME/install-aur.sh"

    # Create a script to run as the user for AUR installation
    cat > "$script_path" << 'AURSCRIPT'
#!/bin/bash
set -e

cd ~

# Install yay
if ! command -v yay &>/dev/null; then
    git clone https://aur.archlinux.org/yay-bin.git
    cd yay-bin
    makepkg -si --noconfirm
    cd ..
    rm -rf yay-bin
fi

# Install walker and elephant with providers
yay -S --noconfirm walker-bin elephant \
    elephant-desktopapplications \
    elephant-windows \
    elephant-clipboard \
    elephant-calc \
    elephant-runner \
    elephant-files \
    elephant-archlinuxpkgs
AURSCRIPT

    chown "$USERNAME:$USERNAME" "$script_path" 2>/dev/null || true
    chmod +x "$script_path"

    # Verify script exists
    if [[ ! -f "$script_path" ]]; then
        die "Failed to create AUR install script!"
    fi

    info "Building and installing yay (AUR helper)..."
    arch-chroot /mnt sudo -u "$USERNAME" bash "/home/$USERNAME/install-aur.sh"

    # Cleanup
    rm -f "$script_path"

    success "AUR packages installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Finish Installation
# -----------------------------------------------------------------------------

finish() {
    header

    gum style \
        --border rounded \
        --border-foreground="#a6e3a1" \
        --padding "1 2" \
        --margin "1" \
        --align center \
        "Installation Complete"

    echo
    gum style \
        --padding "0 2" \
        "Your new Hyprland system is ready!" \
        "" \
        "Next steps:" \
        "  1. Reboot into your new system" \
        "  2. Log in with username: $USERNAME" \
        "  3. Hyprland will start automatically via SDDM" \
        "" \
        "Useful keybinds (defaults):" \
        "  SUPER + Enter    → Open terminal (Ghostty)" \
        "  SUPER + D        → Application launcher (Walker)" \
        "  SUPER + Q        → Close window" \
        "  SUPER + 1-9      → Switch workspace"

    echo
    if gum confirm "Reboot now?"; then
        umount -R /mnt
        reboot
    else
        info "You can reboot manually when ready."
        info "Run 'umount -R /mnt' before rebooting."
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        die "This script must be run as root!"
    fi

    # Check for required tools
    if ! command -v gum &>/dev/null; then
        die "gum is not installed!"
    fi

    welcome
    select_disk
    configure_user
    partition_disk
    format_partitions
    mount_partitions
    check_network
    install_base
    configure_system
    configure_swap
    install_aur_packages
    finish
}

main "$@"
