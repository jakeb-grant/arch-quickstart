#!/usr/bin/env bash
#
# Hyprland Arch Installer
# A beautiful TUI installer for a custom Hyprland desktop
#

set -eEo pipefail

# Trap errors and show what failed
trap 'echo ""; echo "ERROR: Command failed at line $LINENO: $BASH_COMMAND"; echo "Press Enter to exit..."; read' ERR

# Colors for gum
export GUM_CHOOSE_CURSOR_FOREGROUND="#89b4fa"
export GUM_CHOOSE_SELECTED_FOREGROUND="#a6e3a1"
export GUM_INPUT_CURSOR_FOREGROUND="#89b4fa"
export GUM_INPUT_PROMPT_FOREGROUND="#cba6f7"
export GUM_CONFIRM_PROMPT_FOREGROUND="#f9e2af"
export GUM_SPIN_SPINNER_FOREGROUND="#89b4fa"

# Package list location
PACKAGES_FILE="/root/target-packages.x86_64"
CONFIG_FILE="/root/install.conf"

# Offline installation mode
OFFLINE_REPO="/opt/offline-repo"
OFFLINE_MODE=0

# Load configuration defaults
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Fallback defaults if config not found
DEFAULT_USERNAME="${DEFAULT_USERNAME:-user}"
DEFAULT_TIMEZONE="${DEFAULT_TIMEZONE:-America/Denver}"
DEFAULT_LOCALE="${DEFAULT_LOCALE:-en_US.UTF-8}"
DEFAULT_KEYMAP="${DEFAULT_KEYMAP:-us}"
DEFAULT_SHELL="${DEFAULT_SHELL:-/bin/zsh}"
GIT_USER_NAME="${GIT_USER_NAME:-}"
GIT_USER_EMAIL="${GIT_USER_EMAIL:-}"

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

die() {
    gum style --foreground="#f38ba8" --bold "ERROR: $1"
    exit 1
}

info() {
    gum style --foreground="#89b4fa" "$1"
}

success() {
    gum style --foreground="#a6e3a1" "$1"
}

warn() {
    gum style --foreground="#f9e2af" "$1"
}

header() {
    clear
    gum style \
        --border double \
        --border-foreground="#cba6f7" \
        --padding "1 2" \
        --margin "1" \
        --align center \
        --bold \
        "Hyprland Arch Installer"
    echo
}

# -----------------------------------------------------------------------------
# Offline Mode Detection
# -----------------------------------------------------------------------------

detect_offline_mode() {
    if [[ -d "$OFFLINE_REPO" ]] && [[ -f "$OFFLINE_REPO/offline.db.tar.zst" ]]; then
        OFFLINE_MODE=1
        return 0
    fi
    OFFLINE_MODE=0
    return 0
}

# -----------------------------------------------------------------------------
# Offline Repository Validation
# -----------------------------------------------------------------------------

validate_offline_repo() {
    # Only validate in offline mode
    if [[ "$OFFLINE_MODE" -ne 1 ]]; then
        return 0
    fi

    header
    info "Validating offline repository..."
    echo

    local missing_packages=()
    local available_packages

    # Create temp db path for checking
    mkdir -p /tmp/pacman-db-check/sync
    if ! cp "$OFFLINE_REPO"/*.db* /tmp/pacman-db-check/sync/ 2>/dev/null; then
        warn "Could not read offline repository database"
        warn "Skipping validation"
        rm -rf /tmp/pacman-db-check
        return 0
    fi

    # Get list of packages available in offline repo
    available_packages=$(pacman -Sl --dbpath /tmp/pacman-db-check offline 2>/dev/null | awk '{print $2}' || true)

    # Check target packages
    if [[ -f "$PACKAGES_FILE" ]]; then
        while IFS= read -r pkg || [[ -n "$pkg" ]]; do
            [[ "$pkg" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${pkg// }" ]] && continue
            if ! echo "$available_packages" | grep -qx "$pkg"; then
                missing_packages+=("$pkg")
            fi
        done < "$PACKAGES_FILE"
    fi

    # Check AUR packages
    local aur_packages_file="/root/aur-packages.x86_64"
    if [[ -f "$aur_packages_file" ]]; then
        while IFS= read -r pkg || [[ -n "$pkg" ]]; do
            [[ "$pkg" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${pkg// }" ]] && continue
            if ! echo "$available_packages" | grep -qx "$pkg"; then
                missing_packages+=("$pkg")
            fi
        done < "$aur_packages_file"
    fi

    # Cleanup
    rm -rf /tmp/pacman-db-check

    # Report results
    if [[ ${#missing_packages[@]} -gt 0 ]]; then
        warn "WARNING: ${#missing_packages[@]} packages missing from offline repository:"
        echo
        for pkg in "${missing_packages[@]}"; do
            echo "  - $pkg"
        done
        echo
        warn "These packages will fail to install in offline mode."
        echo
        if ! gum confirm --default=false "Continue anyway?"; then
            die "Installation cancelled - offline repository incomplete"
        fi
    else
        success "All required packages found in offline repository!"
        sleep 1
    fi
}

# -----------------------------------------------------------------------------
# Network Check
# -----------------------------------------------------------------------------

check_network() {
    header

    # In offline mode, network is optional (only needed for dotfiles)
    if [[ "$OFFLINE_MODE" -eq 1 ]]; then
        success "Offline mode: All packages are pre-installed on this ISO"
        echo
        info "Checking network connectivity (optional for dotfiles)..."
        echo

        if ping -c 1 -W 3 archlinux.org &>/dev/null; then
            success "Network connected! (dotfiles setup will be available)"
        else
            warn "No network connection - dotfiles setup will be skipped"
        fi
        sleep 2
        return 0
    fi

    # Online mode - network is required
    info "Checking network connectivity..."
    echo

    # Test internet connectivity
    if ping -c 1 -W 3 archlinux.org &>/dev/null; then
        success "Network connected!"
        sleep 1
        return 0
    fi

    warn "No internet connection detected."
    echo

    # Check if WiFi interfaces exist
    if [[ -d /sys/class/net ]] && ls /sys/class/net | grep -qE '^wl'; then
        if gum confirm "Would you like to connect to WiFi?"; then
            connect_wifi
        else
            die "Internet connection required for installation."
        fi
    else
        die "No network connection. Please connect via ethernet and restart."
    fi
}

connect_wifi() {
    header
    info "Scanning for WiFi networks..."
    echo

    # Make sure iwd is running
    systemctl start iwd 2>/dev/null || true
    sleep 2

    # Get WiFi interface name
    local wifi_device
    wifi_device=$(iwctl device list 2>/dev/null | awk '/station/{print $2}' | head -1)

    if [[ -z "$wifi_device" ]]; then
        die "No WiFi device found!"
    fi

    # Scan for networks
    iwctl station "$wifi_device" scan 2>/dev/null || true
    sleep 3

    # Get list of WiFi networks
    local networks
    networks=$(iwctl station "$wifi_device" get-networks 2>/dev/null | tail -n +5 | awk '{print $1}' | grep -v '^$' | sort -u)

    if [[ -z "$networks" ]]; then
        warn "No WiFi networks found. Rescanning..."
        iwctl station "$wifi_device" scan 2>/dev/null || true
        sleep 3
        networks=$(iwctl station "$wifi_device" get-networks 2>/dev/null | tail -n +5 | awk '{print $1}' | grep -v '^$' | sort -u)
    fi

    if [[ -z "$networks" ]]; then
        die "No WiFi networks found!"
    fi

    info "Select WiFi network:"
    local ssid
    ssid=$(echo "$networks" | gum choose --height=15)

    if [[ -z "$ssid" ]]; then
        die "No network selected!"
    fi

    info "Enter password for '$ssid':"
    local wifi_password
    wifi_password=$(gum input --password --placeholder "WiFi password")

    info "Connecting to '$ssid'..."
    if iwctl --passphrase "$wifi_password" station "$wifi_device" connect "$ssid" 2>&1; then
        sleep 2
        if ping -c 1 -W 3 archlinux.org &>/dev/null; then
            success "Connected to WiFi!"
            sleep 1
            return 0
        fi
    fi

    warn "Failed to connect. Try again?"
    if gum confirm; then
        connect_wifi
    else
        die "Internet connection required for installation."
    fi
}

# -----------------------------------------------------------------------------
# Welcome Screen
# -----------------------------------------------------------------------------

welcome() {
    header

    # Show installation mode
    if [[ "$OFFLINE_MODE" -eq 1 ]]; then
        gum style \
            --foreground="#a6e3a1" \
            --bold \
            --padding "0 2" \
            "OFFLINE MODE - All packages pre-installed on ISO"
        echo
    fi

    gum style \
        --padding "1 2" \
        --margin "0 2" \
        "Welcome to the Hyprland Arch Linux installer!" \
        "" \
        "This will install a clean Arch Linux system with:" \
        "  • Hyprland compositor" \
        "  • SDDM display manager" \
        "  • Waybar, Walker, Ghostty" \
        "  • Firefox, Nautilus" \
        "  • Pipewire audio"

    echo
    if ! gum confirm "Ready to proceed?"; then
        gum style --foreground="#f9e2af" "Installation cancelled."
        exit 0
    fi
}

# -----------------------------------------------------------------------------
# Disk Selection
# -----------------------------------------------------------------------------

select_disk() {
    header
    info "Scanning for available disks..."
    echo

    # Get list of disks (exclude loop devices and rom)
    local disks
    mapfile -t disks < <(lsblk -dpno NAME,SIZE,MODEL | grep -E '^/dev/(sd|nvme|vd)' | sort)

    if [[ ${#disks[@]} -eq 0 ]]; then
        die "No suitable disks found!"
    fi

    gum style --foreground="#cba6f7" "Select the target disk for installation:"
    echo

    DISK=$(printf '%s\n' "${disks[@]}" | gum choose --height=10)
    DISK=$(echo "$DISK" | awk '{print $1}')

    if [[ -z "$DISK" ]]; then
        die "No disk selected!"
    fi

    echo
    warn "WARNING: All data on $DISK will be destroyed!"
    echo

    lsblk "$DISK"
    echo

    if ! gum confirm --default=false "Are you sure you want to erase $DISK?"; then
        die "Installation cancelled by user."
    fi

    # Double confirmation for safety
    echo
    gum style --foreground="#f38ba8" "Type 'yes' to confirm disk erasure:"
    CONFIRM=$(gum input --placeholder "Type 'yes' to confirm")

    if [[ "$CONFIRM" != "yes" ]]; then
        die "Installation cancelled."
    fi
}

# -----------------------------------------------------------------------------
# User Configuration
# -----------------------------------------------------------------------------

configure_user() {
    header
    gum style --foreground="#cba6f7" "Configure your system:"
    echo

    # Hostname - select from predefined options
    info "Select machine type:"
    if [[ ${#DEFAULT_HOSTNAME_OPTIONS[@]} -gt 0 ]]; then
        HOSTNAME=$(printf '%s\n' "${DEFAULT_HOSTNAME_OPTIONS[@]}" | gum choose)
    else
        HOSTNAME=$(gum input --placeholder "archlinux" --value "archlinux")
    fi
    HOSTNAME=${HOSTNAME:-archlinux}

    echo

    # Username - pre-filled with default
    info "Enter username:"
    USERNAME=$(gum input --placeholder "$DEFAULT_USERNAME" --value "$DEFAULT_USERNAME")
    USERNAME=${USERNAME:-$DEFAULT_USERNAME}

    if [[ -z "$USERNAME" ]]; then
        die "Username cannot be empty!"
    fi

    echo

    # Password - must be entered
    info "Enter password for $USERNAME:"
    PASSWORD=$(gum input --password --placeholder "Password")

    if [[ -z "$PASSWORD" ]]; then
        die "Password cannot be empty!"
    fi

    info "Confirm password:"
    PASSWORD_CONFIRM=$(gum input --password --placeholder "Confirm password")

    if [[ "$PASSWORD" != "$PASSWORD_CONFIRM" ]]; then
        die "Passwords do not match!"
    fi

    echo

    # Disk encryption
    ENCRYPT_DISK="no"
    ENCRYPT_PASSWORD=""
    info "Disk encryption (LUKS):"
    if gum confirm --default=false "Enable full disk encryption?"; then
        ENCRYPT_DISK="yes"
        if gum confirm "Use the same password for encryption?"; then
            ENCRYPT_PASSWORD="$PASSWORD"
        else
            info "Enter encryption passphrase:"
            ENCRYPT_PASSWORD=$(gum input --password --placeholder "Encryption passphrase")
            if [[ -z "$ENCRYPT_PASSWORD" ]]; then
                die "Encryption passphrase cannot be empty!"
            fi
            info "Confirm encryption passphrase:"
            local encrypt_confirm
            encrypt_confirm=$(gum input --password --placeholder "Confirm passphrase")
            if [[ "$ENCRYPT_PASSWORD" != "$encrypt_confirm" ]]; then
                die "Encryption passphrases do not match!"
            fi
        fi
    fi

    echo

    # Timezone - pre-filled with default, option to change
    info "Timezone (default: $DEFAULT_TIMEZONE):"
    if gum confirm "Use default timezone ($DEFAULT_TIMEZONE)?"; then
        TIMEZONE="$DEFAULT_TIMEZONE"
    else
        TIMEZONE=$(find /usr/share/zoneinfo -type f | sed 's|/usr/share/zoneinfo/||' | grep -E '^(America|Europe|Asia|Australia|Pacific)' | sort | gum filter --height=15 --placeholder="Search timezone..." --value="America/")
        TIMEZONE=${TIMEZONE:-$DEFAULT_TIMEZONE}
    fi

    echo

    # Git configuration - pre-filled with defaults, editable
    info "Git configuration:"
    info "  Git username:"
    GIT_USER_NAME=$(gum input --placeholder "Git username" --value "$GIT_USER_NAME")

    info "  Git email:"
    GIT_USER_EMAIL=$(gum input --placeholder "Git email" --value "$GIT_USER_EMAIL")

    echo
    success "Configuration summary:"
    echo "  Machine:    $HOSTNAME"
    echo "  Username:   $USERNAME"
    echo "  Encryption: $ENCRYPT_DISK"
    echo "  Timezone:   $TIMEZONE"
    echo "  Locale:     $DEFAULT_LOCALE"
    echo "  Keymap:     $DEFAULT_KEYMAP"
    if [[ -n "$GIT_USER_NAME" ]]; then
        echo "  Git user:   $GIT_USER_NAME <$GIT_USER_EMAIL>"
    fi
    echo

    if ! gum confirm "Proceed with these settings?"; then
        configure_user
    fi
}

# -----------------------------------------------------------------------------
# Extra Configuration (GPU, Firewall)
# -----------------------------------------------------------------------------

configure_extras() {
    header
    gum style --foreground="#cba6f7" "Configure additional system settings:"
    echo

    # -------------------------------------------------------------------------
    # GPU Detection and Selection
    # -------------------------------------------------------------------------
    info "Detecting graphics hardware..."
    echo

    # Get all GPU info
    local all_gpus
    all_gpus=$(lspci | grep -iE 'vga|3d|display' || true)

    # Detect individual GPUs
    DETECTED_NVIDIA=$(echo "$all_gpus" | grep -i 'nvidia' | head -1 || true)
    DETECTED_INTEL=$(echo "$all_gpus" | grep -iE 'intel.*(graphics|hd|uhd|iris|xe|arc)' | head -1 || true)
    DETECTED_AMD=$(echo "$all_gpus" | grep -iE 'amd|radeon|ati' | head -1 || true)

    # Check if AMD is an APU (integrated)
    local amd_is_igpu=false
    if [[ -n "$DETECTED_AMD" ]]; then
        if echo "$DETECTED_AMD" | grep -qiE 'Radeon Graphics$|Ryzen.*Radeon|Renoir|Cezanne|Barcelo|Phoenix|Rembrandt|Lucienne|Mendocino'; then
            amd_is_igpu=true
        fi
    fi

    # Display detected hardware
    gum style --foreground="#89b4fa" "Detected graphics hardware:"
    if [[ -n "$DETECTED_NVIDIA" ]]; then
        echo "  • NVIDIA: $(echo "$DETECTED_NVIDIA" | sed 's/.*: //')"
    fi
    if [[ -n "$DETECTED_INTEL" ]]; then
        echo "  • Intel:  $(echo "$DETECTED_INTEL" | sed 's/.*: //')"
    fi
    if [[ -n "$DETECTED_AMD" ]]; then
        if [[ "$amd_is_igpu" == "true" ]]; then
            echo "  • AMD:    $(echo "$DETECTED_AMD" | sed 's/.*: //') (integrated)"
        else
            echo "  • AMD:    $(echo "$DETECTED_AMD" | sed 's/.*: //') (discrete)"
        fi
    fi
    if [[ -z "$DETECTED_NVIDIA" && -z "$DETECTED_INTEL" && -z "$DETECTED_AMD" ]]; then
        warn "  No recognized GPU detected"
    fi
    echo

    # Build GPU options and determine recommendation
    local gpu_options=()
    local recommended=""

    if [[ -n "$DETECTED_NVIDIA" ]]; then
        # NVIDIA present - check for hybrid
        if [[ -n "$DETECTED_INTEL" || "$amd_is_igpu" == "true" ]]; then
            gpu_options+=("nvidia-setup (hybrid graphics - recommended)")
            recommended="nvidia-setup (hybrid graphics - recommended)"
        else
            gpu_options+=("nvidia-setup (NVIDIA)")
            recommended="nvidia-setup (NVIDIA)"
        fi
    fi

    if [[ -n "$DETECTED_INTEL" && -z "$DETECTED_NVIDIA" ]]; then
        gpu_options+=("intel-setup (Intel)")
        [[ -z "$recommended" ]] && recommended="intel-setup (Intel)"
    fi

    if [[ -n "$DETECTED_AMD" && -z "$DETECTED_NVIDIA" ]]; then
        if [[ "$amd_is_igpu" == "true" ]]; then
            gpu_options+=("amd-setup (AMD integrated)")
        else
            gpu_options+=("amd-setup (AMD discrete)")
        fi
        [[ -z "$recommended" ]] && recommended="${gpu_options[-1]}"
    fi

    # Always add skip option
    gpu_options+=("Skip GPU setup")

    # Show recommendation if we have one
    if [[ -n "$recommended" ]]; then
        success "Recommended: $recommended"
        echo
    fi

    info "Select GPU setup:"
    GPU_SETUP=$(printf '%s\n' "${gpu_options[@]}" | gum choose)

    # Extract just the script name from selection
    case "$GPU_SETUP" in
        nvidia-setup*) GPU_SETUP="nvidia" ;;
        intel-setup*)  GPU_SETUP="intel" ;;
        amd-setup*)    GPU_SETUP="amd" ;;
        *)             GPU_SETUP="skip" ;;
    esac

    echo

    # -------------------------------------------------------------------------
    # Firewall Rules Selection
    # -------------------------------------------------------------------------
    info "Firewall Configuration:"
    echo
    gum style --foreground="#89b4fa" "Select firewall rules to enable (space to select, enter to confirm):"
    echo

    # Use gum choose with --no-limit for multi-select
    FIREWALL_RULES=$(gum choose --no-limit \
        "SSH (port 22)" \
        "HTTP/HTTPS (ports 80, 443)" \
        "KDE Connect / GSConnect (ports 1714-1764)")

    echo
    success "Configuration summary:"
    echo "  GPU Setup:  $GPU_SETUP"
    echo -n "  Firewall:   "
    if [[ -z "$FIREWALL_RULES" ]]; then
        echo "Default deny (no extra rules)"
    else
        echo "$FIREWALL_RULES" | tr '\n' ', ' | sed 's/, $//'
        echo
    fi
    echo

    if ! gum confirm "Proceed with these settings?"; then
        configure_extras
    fi
}

# -----------------------------------------------------------------------------
# Partitioning
# -----------------------------------------------------------------------------

partition_disk() {
    header
    info "Partitioning $DISK..."
    echo

    gum spin --spinner dot --title "Wiping disk..." -- \
        wipefs -af "$DISK"

    gum spin --spinner dot --title "Creating partition table..." -- \
        parted -s "$DISK" mklabel gpt

    gum spin --spinner dot --title "Creating EFI partition (512MB)..." -- \
        parted -s "$DISK" mkpart primary fat32 1MiB 513MiB

    gum spin --spinner dot --title "Setting EFI flags..." -- \
        parted -s "$DISK" set 1 esp on

    gum spin --spinner dot --title "Creating root partition..." -- \
        parted -s "$DISK" mkpart primary btrfs 513MiB 100%

    sleep 1  # Wait for kernel to update partition table

    # Determine partition names (handle nvme vs sd naming)
    if [[ "$DISK" == *"nvme"* ]]; then
        EFI_PART="${DISK}p1"
        ROOT_PART="${DISK}p2"
    else
        EFI_PART="${DISK}1"
        ROOT_PART="${DISK}2"
    fi

    success "Partitioning complete!"
    echo
    lsblk "$DISK"
    sleep 2
}

# -----------------------------------------------------------------------------
# Formatting
# -----------------------------------------------------------------------------

format_partitions() {
    header
    info "Formatting partitions..."
    echo

    info "Formatting EFI partition (FAT32)..."
    mkfs.fat -F32 "$EFI_PART"

    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        info "Setting up LUKS encryption..."
        echo -n "$ENCRYPT_PASSWORD" | cryptsetup luksFormat --type luks2 "$ROOT_PART" -

        info "Opening encrypted container..."
        echo -n "$ENCRYPT_PASSWORD" | cryptsetup open "$ROOT_PART" cryptroot -

        # Store the mapper device for later use
        CRYPT_DEVICE="/dev/mapper/cryptroot"

        info "Formatting encrypted partition (BTRFS)..."
        mkfs.btrfs -f "$CRYPT_DEVICE"
    else
        info "Formatting root partition (BTRFS)..."
        mkfs.btrfs -f "$ROOT_PART"
        CRYPT_DEVICE=""
    fi

    success "Formatting complete!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Mount Partitions
# -----------------------------------------------------------------------------

mount_partitions() {
    header
    info "Mounting partitions..."
    echo

    # Determine which device to mount (encrypted or plain)
    local mount_device
    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        mount_device="$CRYPT_DEVICE"
    else
        mount_device="$ROOT_PART"
    fi

    # Mount root
    mount "$mount_device" /mnt

    # Create BTRFS subvolumes
    info "Creating BTRFS subvolumes..."
    btrfs subvolume create /mnt/@
    btrfs subvolume create /mnt/@home
    btrfs subvolume create /mnt/@snapshots
    btrfs subvolume create /mnt/@var_log
    btrfs subvolume create /mnt/@swap

    # Unmount and remount with subvolumes
    umount /mnt

    mount -o noatime,compress=zstd,space_cache=v2,subvol=@ "$mount_device" /mnt

    mkdir -p /mnt/{boot,home,.snapshots,var/log,swap}

    mount -o noatime,compress=zstd,space_cache=v2,subvol=@home "$mount_device" /mnt/home
    mount -o noatime,compress=zstd,space_cache=v2,subvol=@snapshots "$mount_device" /mnt/.snapshots
    mount -o noatime,compress=zstd,space_cache=v2,subvol=@var_log "$mount_device" /mnt/var/log
    # Swap subvolume: no compression, no copy-on-write
    mount -o noatime,nodatacow,subvol=@swap "$mount_device" /mnt/swap

    mount "$EFI_PART" /mnt/boot

    success "Partitions mounted!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install Base System
# -----------------------------------------------------------------------------

install_base() {
    header
    info "Installing base system..."
    echo

    # Initialize pacman keyring
    info "Initializing pacman keyring..."
    pacman-key --init
    pacman-key --populate archlinux

    # Pre-configure locale in target before package install
    # Some packages check locale during installation
    info "Pre-configuring locale..."
    mkdir -p /mnt/etc
    echo "$DEFAULT_LOCALE UTF-8" > /mnt/etc/locale.gen
    echo "LANG=$DEFAULT_LOCALE" > /mnt/etc/locale.conf
    echo "KEYMAP=$DEFAULT_KEYMAP" > /mnt/etc/vconsole.conf

    # Read packages from file
    if [[ -f "$PACKAGES_FILE" ]]; then
        mapfile -t packages < <(grep -v '^#' "$PACKAGES_FILE" | grep -v '^$')
    else
        # Fallback to essential packages if file not found
        packages=(base linux linux-firmware grub efibootmgr iwd)
        warn "Package list not found, installing minimal system..."
    fi

    info "Installing ${#packages[@]} packages..."
    echo

    if [[ "$OFFLINE_MODE" -eq 1 ]]; then
        # Offline installation using local repository
        info "Using offline repository (no download required)..."
        echo

        # Copy offline repository to target
        mkdir -p /mnt/opt/offline-repo
        cp -r "$OFFLINE_REPO"/* /mnt/opt/offline-repo/

        # Create pacman.conf for target that uses offline repo
        mkdir -p /mnt/etc/pacman.d
        cp /etc/pacman.d/offline-pacman.conf /mnt/etc/pacman.conf

        # Install packages with pacstrap using offline config
        pacstrap -C /etc/pacman.d/offline-pacman.conf -K /mnt "${packages[@]}"
    else
        # Online installation (original behavior)
        info "This will take several minutes (downloading packages)..."
        echo

        # Sync package databases
        info "Syncing package databases..."
        pacman -Sy

        # Install packages with pacstrap
        pacstrap -K /mnt "${packages[@]}"
    fi

    # Verify installation succeeded
    if [[ ! -x /mnt/usr/bin/ln ]]; then
        die "Base system installation failed - coreutils not found!"
    fi

    success "Base system installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Configure System
# -----------------------------------------------------------------------------

configure_system() {
    header
    info "Configuring system..."
    echo

    # Generate fstab
    info "  Generating fstab..."
    genfstab -U /mnt >> /mnt/etc/fstab

    # Copy pacman.conf with multilib enabled
    info "  Copying pacman.conf (multilib enabled)..."
    if [[ "$OFFLINE_MODE" -eq 1 ]]; then
        # In offline mode, keep the offline pacman.conf (set during install_base)
        # Just ensure mirrorlist is copied for future online updates
        cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist
    else
        cp /etc/pacman.conf /mnt/etc/pacman.conf
        cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist
    fi

    # Timezone
    info "  Setting timezone..."
    arch-chroot /mnt ln -sf "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
    arch-chroot /mnt hwclock --systohc

    # Generate locale (config was set before pacstrap)
    info "  Generating locale..."
    arch-chroot /mnt locale-gen

    # Hostname
    info "  Setting hostname..."
    echo "$HOSTNAME" > /mnt/etc/hostname
    cat > /mnt/etc/hosts << EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   $HOSTNAME.localdomain $HOSTNAME
EOF

    # Create user
    info "  Creating user $USERNAME..."
    arch-chroot /mnt useradd -m -G wheel -s "$DEFAULT_SHELL" "$USERNAME"
    echo "$USERNAME:$PASSWORD" | arch-chroot /mnt chpasswd

    # Copy custom Hyprland config to user's home
    info "  Installing Hyprland config..."
    mkdir -p "/mnt/home/$USERNAME/.config/hypr"
    cp /etc/skel/.config/hypr/hyprland.conf "/mnt/home/$USERNAME/.config/hypr/"
    arch-chroot /mnt chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.config"

    # Configure git for user
    if [[ -n "$GIT_USER_NAME" && -n "$GIT_USER_EMAIL" ]]; then
        info "  Configuring git..."
        arch-chroot /mnt sudo -u "$USERNAME" git config --global user.name "$GIT_USER_NAME"
        arch-chroot /mnt sudo -u "$USERNAME" git config --global user.email "$GIT_USER_EMAIL"
        arch-chroot /mnt sudo -u "$USERNAME" git config --global init.defaultBranch main
    fi

    # Enable sudo for wheel group
    info "  Configuring sudo..."
    sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /mnt/etc/sudoers

    # Configure encryption if enabled
    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        info "  Configuring disk encryption..."

        # Get UUID of the encrypted partition
        local crypt_uuid
        crypt_uuid=$(blkid -s UUID -o value "$ROOT_PART")

        # Add encrypt hook to mkinitcpio
        sed -i 's/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block encrypt filesystems fsck)/' /mnt/etc/mkinitcpio.conf

        # Configure GRUB for encrypted root
        sed -i "s|^GRUB_CMDLINE_LINUX=\"\"|GRUB_CMDLINE_LINUX=\"cryptdevice=UUID=$crypt_uuid:cryptroot root=/dev/mapper/cryptroot\"|" /mnt/etc/default/grub

        # Regenerate initramfs
        info "  Regenerating initramfs..."
        arch-chroot /mnt mkinitcpio -P
    fi

    # Install bootloader
    info "  Installing GRUB bootloader..."
    arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB
    arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg

    # Enable services
    info "  Enabling services..."
    arch-chroot /mnt systemctl enable iwd
    arch-chroot /mnt systemctl enable systemd-resolved
    arch-chroot /mnt systemctl enable sddm

    # Configure iwd with systemd-resolved
    info "  Configuring iwd..."
    mkdir -p /mnt/etc/iwd
    cat > /mnt/etc/iwd/main.conf << 'EOF'
[General]
EnableNetworkConfiguration=true

[Network]
NameResolvingService=systemd
EOF

    # Link resolv.conf to systemd-resolved
    ln -sf /run/systemd/resolve/stub-resolv.conf /mnt/etc/resolv.conf

    # Copy setup scripts to installed system
    info "  Installing setup scripts..."
    for script in nvidia-setup intel-setup amd-setup bluetooth-setup printer-setup firewall-setup dotfiles-setup; do
        if [[ -f "/usr/local/bin/$script" ]]; then
            cp "/usr/local/bin/$script" "/mnt/usr/local/bin/"
            chmod +x "/mnt/usr/local/bin/$script"
        fi
    done

    success "System configured!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Configure Swap
# -----------------------------------------------------------------------------

configure_swap() {
    header
    info "Configuring swap file..."
    echo

    # Get total RAM in MB
    local ram_mb
    ram_mb=$(free -m | awk '/^Mem:/{print $2}')

    # Calculate swap size based on RAM (for hibernate support, match RAM)
    # Best practices:
    #   RAM <= 2GB:  2x RAM
    #   RAM 2-8GB:   Equal to RAM
    #   RAM > 8GB:   Equal to RAM (cap at 16GB for practicality)
    local swap_mb
    if [[ $ram_mb -le 2048 ]]; then
        swap_mb=$((ram_mb * 2))
    elif [[ $ram_mb -gt 16384 ]]; then
        swap_mb=16384  # Cap at 16GB
    else
        swap_mb=$ram_mb
    fi

    local swap_gb=$((swap_mb / 1024))
    info "Detected RAM: ${ram_mb}MB"
    info "Creating swap file: ${swap_gb}GB (${swap_mb}MB)"

    # Create swap file with proper attributes for BTRFS
    # The @swap subvolume is already mounted with nodatacow
    info "  Creating swap file (this may take a moment)..."

    # Use truncate for instant allocation, then chattr for safety
    truncate -s 0 /mnt/swap/swapfile
    chattr +C /mnt/swap/swapfile  # Disable copy-on-write

    # Allocate the actual space
    dd if=/dev/zero of=/mnt/swap/swapfile bs=1M count="$swap_mb" status=progress

    # Set permissions (must be 600)
    chmod 600 /mnt/swap/swapfile

    # Format as swap
    info "  Formatting swap file..."
    mkswap /mnt/swap/swapfile

    # Add to fstab
    info "  Adding swap to fstab..."
    echo "/swap/swapfile none swap defaults 0 0" >> /mnt/etc/fstab

    success "Swap file configured! (${swap_gb}GB)"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install Extra Packages (Bluetooth, Printer, Firewall, GPU)
# -----------------------------------------------------------------------------

install_extras() {
    header
    info "Installing additional system components..."
    echo

    # Set environment variables for chroot-aware scripts
    export CHROOT_TARGET="/mnt"
    export CHROOT_USER="$USERNAME"
    export NONINTERACTIVE="1"

    # Export detected GPU info so scripts don't need to re-detect
    export DETECTED_NVIDIA
    export DETECTED_INTEL
    export DETECTED_AMD

    # -------------------------------------------------------------------------
    # Bluetooth Setup (automatic)
    # -------------------------------------------------------------------------
    info "Setting up Bluetooth..."
    /usr/local/bin/bluetooth-setup
    success "  Bluetooth configured!"
    echo

    # -------------------------------------------------------------------------
    # Printer Setup (automatic)
    # -------------------------------------------------------------------------
    info "Setting up printing (CUPS)..."
    /usr/local/bin/printer-setup
    success "  Printing configured!"
    echo

    # -------------------------------------------------------------------------
    # Firewall Setup (with user-selected rules)
    # -------------------------------------------------------------------------
    info "Setting up firewall (UFW)..."

    # Build firewall args from selected rules
    local firewall_args=""
    if echo "$FIREWALL_RULES" | grep -q "SSH"; then
        firewall_args="$firewall_args --ssh"
    fi
    if echo "$FIREWALL_RULES" | grep -q "HTTP"; then
        firewall_args="$firewall_args --http"
    fi
    if echo "$FIREWALL_RULES" | grep -q "KDE Connect"; then
        firewall_args="$firewall_args --kdeconnect"
    fi

    /usr/local/bin/firewall-setup $firewall_args
    success "  Firewall configured!"
    echo

    # -------------------------------------------------------------------------
    # GPU Setup (based on user selection)
    # -------------------------------------------------------------------------
    if [[ "$GPU_SETUP" != "skip" ]]; then
        info "Setting up GPU drivers ($GPU_SETUP)..."
        echo

        case "$GPU_SETUP" in
            nvidia)
                /usr/local/bin/nvidia-setup
                ;;
            intel)
                /usr/local/bin/intel-setup
                ;;
            amd)
                /usr/local/bin/amd-setup
                ;;
        esac

        success "  GPU drivers configured!"
    else
        info "Skipping GPU setup (can be run later with *-setup scripts)"
    fi

    # Clear environment
    unset CHROOT_TARGET CHROOT_USER NONINTERACTIVE

    echo
    success "Additional components installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install AUR Packages
# -----------------------------------------------------------------------------

install_aur_packages() {
    header
    info "Installing AUR packages..."
    echo

    # Read AUR packages from config file (excluding comments and blank lines)
    local aur_packages_file="/root/aur-packages.x86_64"
    local aur_packages=()

    if [[ ! -f "$aur_packages_file" ]]; then
        warn "AUR packages file not found: $aur_packages_file"
        warn "Skipping AUR package installation"
        return 0
    fi

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and blank lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        aur_packages+=("$line")
    done < "$aur_packages_file"

    if [[ ${#aur_packages[@]} -eq 0 ]]; then
        info "No AUR packages to install"
        return 0
    fi

    info "Packages to install: ${aur_packages[*]}"
    echo

    if [[ "$OFFLINE_MODE" -eq 1 ]]; then
        # Offline mode: AUR packages are already in the offline repository
        info "Installing pre-built AUR packages from offline repository..."
        echo

        # Track failed packages
        local failed_packages=()

        # Install each AUR package directly with pacman (they're in the offline repo)
        for pkg in "${aur_packages[@]}"; do
            info "  Installing $pkg..."
            if ! arch-chroot /mnt pacman -S --noconfirm "$pkg" 2>/dev/null; then
                warn "  Failed to install $pkg"
                failed_packages+=("$pkg")
            fi
        done

        # Report failures
        if [[ ${#failed_packages[@]} -gt 0 ]]; then
            echo
            warn "WARNING: ${#failed_packages[@]} AUR packages failed to install:"
            for pkg in "${failed_packages[@]}"; do
                echo "  - $pkg"
            done
            echo
            warn "After rebooting, install manually with: yay -S ${failed_packages[*]}"
            sleep 3
        fi
    else
        # Online mode: Build AUR packages with yay
        # Use user's home directory (guaranteed to exist after useradd -m)
        local script_path="/mnt/home/$USERNAME/install-aur.sh"

        # Create a script to run as the user for AUR installation
        cat > "$script_path" << AURSCRIPT
#!/bin/bash
set -e

cd ~

# Install yay
if ! command -v yay &>/dev/null; then
    git clone https://aur.archlinux.org/yay-bin.git
    cd yay-bin
    makepkg -si --noconfirm
    cd ..
    rm -rf yay-bin
fi

# Install AUR packages
yay -S --noconfirm ${aur_packages[*]}
AURSCRIPT

        chown "$USERNAME:$USERNAME" "$script_path" 2>/dev/null || true
        chmod +x "$script_path"

        # Verify script exists
        if [[ ! -f "$script_path" ]]; then
            die "Failed to create AUR install script!"
        fi

        info "Building and installing yay (AUR helper)..."
        arch-chroot /mnt sudo -u "$USERNAME" bash "/home/$USERNAME/install-aur.sh"

        # Cleanup
        rm -f "$script_path"
    fi

    success "AUR packages installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Dotfiles Setup (Optional)
# -----------------------------------------------------------------------------

setup_dotfiles() {
    header
    info "Dotfiles Setup"
    echo

    local dotfiles_source=""
    local local_dotfiles="/opt/dotfiles"

    # Check for pre-loaded dotfiles on the ISO (offline mode)
    if [[ -d "$local_dotfiles" ]] && [[ -d "$local_dotfiles/.git" ]]; then
        success "Found pre-loaded dotfiles on ISO!"
        echo

        if gum confirm "Apply pre-loaded dotfiles using chezmoi?"; then
            # Copy dotfiles to target system
            info "Copying dotfiles to installed system..."
            mkdir -p "/mnt/home/$USERNAME/.local/share/chezmoi-source"
            cp -r "$local_dotfiles"/* "/mnt/home/$USERNAME/.local/share/chezmoi-source/"
            arch-chroot /mnt chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.local"

            info "Applying dotfiles with chezmoi..."
            arch-chroot /mnt sudo -u "$USERNAME" chezmoi init --source="/home/$USERNAME/.local/share/chezmoi-source" --apply || {
                warn "Dotfiles setup encountered an error."
                warn "You can run 'chezmoi init --apply' after rebooting."
                sleep 2
                return
            }

            success "Dotfiles applied successfully!"
            sleep 1
            return
        else
            info "Skipping pre-loaded dotfiles."
        fi
    fi

    # No local dotfiles or user declined - prompt for remote repo
    if ! gum confirm --default=false "Would you like to set up dotfiles from a remote repository?"; then
        info "Skipping dotfiles setup."
        sleep 1
        return
    fi

    # Check if we have network connectivity
    if ! ping -c 1 -W 3 archlinux.org &>/dev/null; then
        warn "No network connection available."
        warn "You can run 'dotfiles-setup <repo>' after rebooting."
        sleep 2
        return
    fi

    echo
    info "Enter your GitHub username or full dotfiles repo URL:"
    info "(e.g., 'jakeb-grant' or 'https://github.com/user/dotfiles.git')"
    echo

    local dotfiles_repo
    dotfiles_repo=$(gum input --placeholder "GitHub username or repo URL")

    if [[ -z "$dotfiles_repo" ]]; then
        warn "No repository specified. Skipping dotfiles setup."
        sleep 1
        return
    fi

    info "Initializing dotfiles from: $dotfiles_repo"
    echo

    # Run chezmoi init as the user in the chroot
    arch-chroot /mnt sudo -u "$USERNAME" chezmoi init "$dotfiles_repo" --apply || {
        warn "Dotfiles setup encountered an error."
        warn "You can run 'dotfiles-setup $dotfiles_repo' after rebooting."
        sleep 2
        return
    }

    success "Dotfiles applied successfully!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Finish Installation
# -----------------------------------------------------------------------------

finish() {
    header

    # Restore standard pacman.conf for online updates after installation
    if [[ "$OFFLINE_MODE" -eq 1 ]]; then
        info "Configuring system for online updates..."

        # Create standard pacman.conf (without offline repo)
        cat > /mnt/etc/pacman.conf << 'PACMANCONF'
#
# /etc/pacman.conf
#
# See the pacman.conf(5) manpage for option and repository directives

[options]
HoldPkg     = pacman glibc
Architecture = auto

# Misc options
CheckSpace
ParallelDownloads = 5
Color
VerbosePkgLists

SigLevel    = Required DatabaseOptional
LocalFileSigLevel = Optional

[core]
Include = /etc/pacman.d/mirrorlist

[extra]
Include = /etc/pacman.d/mirrorlist

[multilib]
Include = /etc/pacman.d/mirrorlist
PACMANCONF

        # Optionally remove offline repo to save disk space
        # Uncomment the following line if you want to remove it:
        # rm -rf /mnt/opt/offline-repo

        success "System configured for online updates"
        echo
    fi

    gum style \
        --border rounded \
        --border-foreground="#a6e3a1" \
        --padding "1 2" \
        --margin "1" \
        --align center \
        "Installation Complete"

    echo
    gum style \
        --padding "0 2" \
        "Your new Hyprland system is ready!" \
        "" \
        "Next steps:" \
        "  1. Reboot into your new system" \
        "  2. Log in with username: $USERNAME" \
        "  3. Hyprland will start automatically via SDDM" \
        "" \
        "Useful keybinds (defaults):" \
        "  SUPER + Enter    → Open terminal (Ghostty)" \
        "  SUPER + D        → Application launcher (Walker)" \
        "  SUPER + Q        → Close window" \
        "  SUPER + 1-9      → Switch workspace"

    echo
    if gum confirm "Reboot now?"; then
        umount -R /mnt
        reboot
    else
        info "You can reboot manually when ready."
        info "Run 'umount -R /mnt' before rebooting."
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        die "This script must be run as root!"
    fi

    # Check for required tools
    if ! command -v gum &>/dev/null; then
        die "gum is not installed!"
    fi

    # Detect if offline repository is available
    detect_offline_mode

    welcome
    validate_offline_repo
    check_network
    select_disk
    configure_user
    configure_extras
    partition_disk
    format_partitions
    mount_partitions
    install_base
    configure_system
    configure_swap
    install_extras
    install_aur_packages
    setup_dotfiles
    finish
}

main "$@"
