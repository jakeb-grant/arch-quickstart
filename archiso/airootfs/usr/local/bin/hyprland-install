#!/usr/bin/env bash
#
# Hyprland Arch Installer
# A beautiful TUI installer for a custom Hyprland desktop
#

set -eEo pipefail

# Trap errors and show what failed
trap 'echo ""; echo "ERROR: Command failed at line $LINENO: $BASH_COMMAND"; echo "Press Enter to exit..."; read' ERR

# Colors for gum
export GUM_CHOOSE_CURSOR_FOREGROUND="#89b4fa"
export GUM_CHOOSE_SELECTED_FOREGROUND="#a6e3a1"
export GUM_INPUT_CURSOR_FOREGROUND="#89b4fa"
export GUM_INPUT_PROMPT_FOREGROUND="#cba6f7"
export GUM_CONFIRM_PROMPT_FOREGROUND="#f9e2af"
export GUM_SPIN_SPINNER_FOREGROUND="#89b4fa"

# Package list location
PACKAGES_FILE="/root/target-packages.x86_64"
CONFIG_FILE="/root/install.conf"

# Load configuration defaults
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Fallback defaults if config not found
DEFAULT_USERNAME="${DEFAULT_USERNAME:-user}"
DEFAULT_TIMEZONE="${DEFAULT_TIMEZONE:-America/Denver}"
DEFAULT_LOCALE="${DEFAULT_LOCALE:-en_US.UTF-8}"
DEFAULT_KEYMAP="${DEFAULT_KEYMAP:-us}"
DEFAULT_SHELL="${DEFAULT_SHELL:-/bin/zsh}"
GIT_USER_NAME="${GIT_USER_NAME:-}"
GIT_USER_EMAIL="${GIT_USER_EMAIL:-}"

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

die() {
    gum style --foreground="#f38ba8" --bold "ERROR: $1"
    exit 1
}

info() {
    gum style --foreground="#89b4fa" "$1"
}

success() {
    gum style --foreground="#a6e3a1" "$1"
}

warn() {
    gum style --foreground="#f9e2af" "$1"
}

header() {
    clear
    gum style \
        --border double \
        --border-foreground="#cba6f7" \
        --padding "1 2" \
        --margin "1" \
        --align center \
        --bold \
        "Hyprland Arch Installer"
    echo
}

# -----------------------------------------------------------------------------
# Installation Type Variables
# -----------------------------------------------------------------------------

INSTALL_TYPE="fresh"        # "fresh" or "dualboot"
EXISTING_EFI_PART=""        # Existing EFI partition for dual-boot
WINDOWS_DETECTED="no"       # Whether Windows was detected
UNALLOCATED_START=""        # Start sector of unallocated space
UNALLOCATED_SIZE=""         # Size of unallocated space in MB

# -----------------------------------------------------------------------------
# Dual-Boot Detection Functions
# -----------------------------------------------------------------------------

# Detect if Windows is installed on a disk
detect_windows() {
    local disk="$1"

    # Use lsblk to check for NTFS partitions on this disk
    if lsblk -lno FSTYPE "$disk" 2>/dev/null | grep -q "ntfs"; then
        WINDOWS_DETECTED="yes"
        return 0
    fi

    WINDOWS_DETECTED="no"
    return 1
}

# Find existing EFI partition on a disk
detect_efi_partition() {
    local disk="$1"

    # Look for partition with ESP flag using parttype GUID
    local efi_part
    efi_part=$(lsblk -lno NAME,PARTTYPE "$disk" 2>/dev/null | \
               grep -i "c12a7328-f81f-11d2-ba4b-00a0c93ec93b" | \
               awk '{print $1}' | head -1)

    if [[ -n "$efi_part" ]]; then
        EXISTING_EFI_PART="/dev/$efi_part"
        return 0
    fi

    EXISTING_EFI_PART=""
    return 1
}

# Find unallocated space on a disk (minimum 20GB)
detect_unallocated_space() {
    local disk="$1"
    local min_size_mb="${2:-20480}"  # Minimum 20GB by default

    # Use parted to find free space
    local free_space
    free_space=$(parted -s "$disk" unit MB print free 2>/dev/null | \
                 grep "Free Space" | \
                 tail -1)

    if [[ -n "$free_space" ]]; then
        # Parse the free space line
        local size_mb
        size_mb=$(echo "$free_space" | awk '{print $3}' | sed 's/MB//')

        if [[ -n "$size_mb" ]] && (( ${size_mb%.*} >= min_size_mb )); then
            UNALLOCATED_START=$(echo "$free_space" | awk '{print $1}')
            UNALLOCATED_SIZE="${size_mb%.*}"
            return 0
        fi
    fi

    UNALLOCATED_START=""
    UNALLOCATED_SIZE=""
    return 1
}

# Get human-readable size
human_size() {
    local size_mb="$1"
    if (( size_mb >= 1024 )); then
        echo "$((size_mb / 1024))GB"
    else
        echo "${size_mb}MB"
    fi
}

# -----------------------------------------------------------------------------
# Network Check
# -----------------------------------------------------------------------------

check_network() {
    header
    info "Checking network connectivity..."
    echo

    # Test internet connectivity
    if ping -c 1 -W 3 archlinux.org &>/dev/null; then
        success "Network connected!"
        sleep 1
        return 0
    fi

    warn "No internet connection detected."
    echo

    # Check if WiFi interfaces exist
    if [[ -d /sys/class/net ]] && ls /sys/class/net | grep -qE '^wl'; then
        if gum confirm "Would you like to connect to WiFi?"; then
            connect_wifi
        else
            die "Internet connection required for installation."
        fi
    else
        die "No network connection. Please connect via ethernet and restart."
    fi
}

connect_wifi() {
    header
    info "Scanning for WiFi networks..."
    echo

    # Make sure iwd is running
    systemctl start iwd 2>/dev/null || true
    sleep 2

    # Get WiFi interface name
    local wifi_device
    wifi_device=$(iwctl device list 2>/dev/null | awk '/station/{print $2}' | head -1)

    if [[ -z "$wifi_device" ]]; then
        die "No WiFi device found!"
    fi

    # Scan for networks
    iwctl station "$wifi_device" scan 2>/dev/null || true
    sleep 3

    # Get list of WiFi networks
    local networks
    networks=$(iwctl station "$wifi_device" get-networks 2>/dev/null | tail -n +5 | awk '{print $1}' | grep -v '^$' | sort -u)

    if [[ -z "$networks" ]]; then
        warn "No WiFi networks found. Rescanning..."
        iwctl station "$wifi_device" scan 2>/dev/null || true
        sleep 3
        networks=$(iwctl station "$wifi_device" get-networks 2>/dev/null | tail -n +5 | awk '{print $1}' | grep -v '^$' | sort -u)
    fi

    if [[ -z "$networks" ]]; then
        die "No WiFi networks found!"
    fi

    info "Select WiFi network:"
    local ssid
    ssid=$(echo "$networks" | gum choose --height=15)

    if [[ -z "$ssid" ]]; then
        die "No network selected!"
    fi

    info "Enter password for '$ssid':"
    local wifi_password
    wifi_password=$(gum input --password --placeholder "WiFi password")

    info "Connecting to '$ssid'..."
    if iwctl --passphrase "$wifi_password" station "$wifi_device" connect "$ssid" 2>&1; then
        sleep 2
        if ping -c 1 -W 3 archlinux.org &>/dev/null; then
            success "Connected to WiFi!"
            sleep 1
            return 0
        fi
    fi

    warn "Failed to connect. Try again?"
    if gum confirm; then
        connect_wifi
    else
        die "Internet connection required for installation."
    fi
}

# -----------------------------------------------------------------------------
# Welcome Screen
# -----------------------------------------------------------------------------

welcome() {
    header
    gum style \
        --padding "1 2" \
        --margin "0 2" \
        "Welcome to the Hyprland Arch Linux installer!" \
        "" \
        "This will install a clean Arch Linux system with:" \
        "  • Hyprland compositor" \
        "  • SDDM display manager" \
        "  • Waybar, Walker, Ghostty" \
        "  • Firefox, Nautilus" \
        "  • Pipewire audio"

    echo
    if ! gum confirm "Ready to proceed?"; then
        gum style --foreground="#f9e2af" "Installation cancelled."
        exit 0
    fi
}

# -----------------------------------------------------------------------------
# Installation Type Selection
# -----------------------------------------------------------------------------

select_install_type() {
    header
    gum style --foreground="#cba6f7" "Select installation type:"
    echo

    INSTALL_TYPE=$(gum choose \
        "Fresh Install (erase entire disk)" \
        "Dual Boot (alongside Windows)")

    if [[ "$INSTALL_TYPE" == *"Fresh"* ]]; then
        INSTALL_TYPE="fresh"
    else
        INSTALL_TYPE="dualboot"
        show_dualboot_warnings
    fi
}

# -----------------------------------------------------------------------------
# Dual-Boot Prerequisites Warning
# -----------------------------------------------------------------------------

show_dualboot_warnings() {
    header
    gum style \
        --foreground="#f9e2af" \
        --bold \
        "⚠  DUAL BOOT REQUIREMENTS"
    echo

    gum style \
        --padding "1 2" \
        --margin "0 2" \
        "Before continuing, ensure you have:" \
        "" \
        "  • Disabled Fast Startup in Windows" \
        "    (Settings → System → Power → Fast Startup → Off)" \
        "" \
        "  • Shrunk your Windows partition to create free space" \
        "    (Disk Management → Right-click C: → Shrink Volume)" \
        "    Minimum 20GB required for Linux" \
        "" \
        "  • Disabled Secure Boot in BIOS/UEFI (if enabled)"

    echo
    warn "Proceeding without these steps may cause data loss or boot issues!"
    echo

    if ! gum confirm "I have completed these steps. Continue?"; then
        gum style --foreground="#f9e2af" "Installation cancelled."
        exit 0
    fi
}

# -----------------------------------------------------------------------------
# Disk Selection
# -----------------------------------------------------------------------------

select_disk() {
    header
    info "Scanning for available disks..."
    echo

    # Get list of disks (exclude loop devices and rom)
    mapfile -t disks < <(lsblk -dpno NAME,SIZE,MODEL | grep -E '^/dev/(sd|nvme|vd)' | sort)

    if [[ ${#disks[@]} -eq 0 ]]; then
        die "No suitable disks found!"
    fi

    if [[ "$INSTALL_TYPE" == "dualboot" ]]; then
        select_disk_dualboot
    else
        select_disk_fresh
    fi
}

select_disk_fresh() {
    gum style --foreground="#cba6f7" "Select the target disk for installation:"
    echo

    DISK=$(printf '%s\n' "${disks[@]}" | gum choose --height=10)
    DISK=$(echo "$DISK" | awk '{print $1}')

    if [[ -z "$DISK" ]]; then
        die "No disk selected!"
    fi

    echo
    warn "WARNING: All data on $DISK will be destroyed!"
    echo

    lsblk "$DISK"
    echo

    if ! gum confirm --default=false "Are you sure you want to erase $DISK?"; then
        die "Installation cancelled by user."
    fi

    # Double confirmation for safety
    echo
    gum style --foreground="#f38ba8" "Type 'yes' to confirm disk erasure:"
    CONFIRM=$(gum input --placeholder "Type 'yes' to confirm")

    if [[ "$CONFIRM" != "yes" ]]; then
        die "Installation cancelled."
    fi
}

select_disk_dualboot() {
    gum style --foreground="#cba6f7" "Select the disk with Windows installed:"
    echo

    # Show disks with Windows detection status
    local disk_info
    for disk_entry in "${disks[@]}"; do
        local disk_name
        disk_name=$(echo "$disk_entry" | awk '{print $1}')
        detect_windows "$disk_name" || true  # Don't fail if no Windows found
        if [[ "$WINDOWS_DETECTED" == "yes" ]]; then
            disk_info+="$disk_entry [Windows detected]"$'\n'
        else
            disk_info+="$disk_entry"$'\n'
        fi
    done

    DISK=$(echo -n "$disk_info" | gum choose --height=10)
    DISK=$(echo "$DISK" | awk '{print $1}')

    if [[ -z "$DISK" ]]; then
        die "No disk selected!"
    fi

    # Verify Windows is on this disk
    detect_windows "$DISK" || true
    if [[ "$WINDOWS_DETECTED" != "yes" ]]; then
        warn "No Windows installation detected on $DISK"
        if ! gum confirm "Continue anyway?"; then
            die "Installation cancelled."
        fi
    fi

    # Check for existing EFI partition
    if ! detect_efi_partition "$DISK"; then
        die "No EFI partition found on $DISK. Is this a UEFI system?"
    fi
    success "Found EFI partition: $EXISTING_EFI_PART"

    # Check for unallocated space
    echo
    info "Checking for unallocated space..."
    if ! detect_unallocated_space "$DISK"; then
        echo
        gum style --foreground="#f38ba8" \
            "ERROR: No unallocated space found (minimum 20GB required)" \
            "" \
            "Please boot into Windows and shrink your partition:" \
            "  1. Open Disk Management (diskmgmt.msc)" \
            "  2. Right-click on C: drive" \
            "  3. Select 'Shrink Volume'" \
            "  4. Shrink by at least 20480 MB (20GB)" \
            "  5. Reboot and run this installer again"
        die "Cannot proceed without unallocated space."
    fi

    success "Found $(human_size "$UNALLOCATED_SIZE") of unallocated space"
    echo

    # Show partition layout
    info "Current partition layout:"
    lsblk "$DISK" -o NAME,SIZE,FSTYPE,LABEL
    echo

    gum style --foreground="#a6e3a1" \
        "Linux will be installed in the unallocated space." \
        "Your Windows installation will NOT be modified."
    echo

    if ! gum confirm "Proceed with dual-boot installation?"; then
        die "Installation cancelled."
    fi
}

# -----------------------------------------------------------------------------
# User Configuration
# -----------------------------------------------------------------------------

configure_user() {
    header
    gum style --foreground="#cba6f7" "Configure your system:"
    echo

    # Hostname - select from predefined options
    info "Select machine type:"
    if [[ ${#DEFAULT_HOSTNAME_OPTIONS[@]} -gt 0 ]]; then
        HOSTNAME=$(printf '%s\n' "${DEFAULT_HOSTNAME_OPTIONS[@]}" | gum choose)
    else
        HOSTNAME=$(gum input --placeholder "archlinux" --value "archlinux")
    fi
    HOSTNAME=${HOSTNAME:-archlinux}

    echo

    # Username - pre-filled with default
    info "Enter username:"
    USERNAME=$(gum input --placeholder "$DEFAULT_USERNAME" --value "$DEFAULT_USERNAME")
    USERNAME=${USERNAME:-$DEFAULT_USERNAME}

    if [[ -z "$USERNAME" ]]; then
        die "Username cannot be empty!"
    fi

    echo

    # Password - must be entered
    info "Enter password for $USERNAME:"
    PASSWORD=$(gum input --password --placeholder "Password")

    if [[ -z "$PASSWORD" ]]; then
        die "Password cannot be empty!"
    fi

    info "Confirm password:"
    PASSWORD_CONFIRM=$(gum input --password --placeholder "Confirm password")

    if [[ "$PASSWORD" != "$PASSWORD_CONFIRM" ]]; then
        die "Passwords do not match!"
    fi

    echo

    # Disk encryption
    ENCRYPT_DISK="no"
    ENCRYPT_PASSWORD=""
    info "Disk encryption (LUKS):"
    if [[ "$INSTALL_TYPE" == "dualboot" ]]; then
        warn "Note: This will only encrypt the Linux partition, not Windows."
    fi
    if gum confirm --default=false "Enable full disk encryption?"; then
        ENCRYPT_DISK="yes"
        if gum confirm "Use the same password for encryption?"; then
            ENCRYPT_PASSWORD="$PASSWORD"
        else
            info "Enter encryption passphrase:"
            ENCRYPT_PASSWORD=$(gum input --password --placeholder "Encryption passphrase")
            if [[ -z "$ENCRYPT_PASSWORD" ]]; then
                die "Encryption passphrase cannot be empty!"
            fi
            info "Confirm encryption passphrase:"
            local encrypt_confirm
            encrypt_confirm=$(gum input --password --placeholder "Confirm passphrase")
            if [[ "$ENCRYPT_PASSWORD" != "$encrypt_confirm" ]]; then
                die "Encryption passphrases do not match!"
            fi
        fi
    fi

    echo

    # Timezone - pre-filled with default, option to change
    info "Timezone (default: $DEFAULT_TIMEZONE):"
    if gum confirm "Use default timezone ($DEFAULT_TIMEZONE)?"; then
        TIMEZONE="$DEFAULT_TIMEZONE"
    else
        TIMEZONE=$(find /usr/share/zoneinfo -type f | sed 's|/usr/share/zoneinfo/||' | grep -E '^(America|Europe|Asia|Australia|Pacific)' | sort | gum filter --height=15 --placeholder="Search timezone..." --value="America/")
        TIMEZONE=${TIMEZONE:-$DEFAULT_TIMEZONE}
    fi

    echo

    # Git configuration - pre-filled with defaults, editable
    info "Git configuration:"
    info "  Git username:"
    GIT_USER_NAME=$(gum input --placeholder "Git username" --value "$GIT_USER_NAME")

    info "  Git email:"
    GIT_USER_EMAIL=$(gum input --placeholder "Git email" --value "$GIT_USER_EMAIL")

    echo
    success "Configuration summary:"
    echo "  Machine:    $HOSTNAME"
    echo "  Username:   $USERNAME"
    echo "  Encryption: $ENCRYPT_DISK"
    echo "  Timezone:   $TIMEZONE"
    echo "  Locale:     $DEFAULT_LOCALE"
    echo "  Keymap:     $DEFAULT_KEYMAP"
    if [[ -n "$GIT_USER_NAME" ]]; then
        echo "  Git user:   $GIT_USER_NAME <$GIT_USER_EMAIL>"
    fi
    echo

    if ! gum confirm "Proceed with these settings?"; then
        configure_user
    fi
}

# -----------------------------------------------------------------------------
# Extra Configuration (GPU, Firewall)
# -----------------------------------------------------------------------------

configure_extras() {
    header
    gum style --foreground="#cba6f7" "Configure additional system settings:"
    echo

    # -------------------------------------------------------------------------
    # GPU Detection and Selection
    # -------------------------------------------------------------------------
    info "Detecting graphics hardware..."
    echo

    # Get all GPU info
    local all_gpus
    all_gpus=$(lspci | grep -iE 'vga|3d|display' || true)

    # Detect individual GPUs
    DETECTED_NVIDIA=$(echo "$all_gpus" | grep -i 'nvidia' | head -1 || true)
    DETECTED_INTEL=$(echo "$all_gpus" | grep -iE 'intel.*(graphics|hd|uhd|iris|xe|arc)' | head -1 || true)
    DETECTED_AMD=$(echo "$all_gpus" | grep -iE 'amd|radeon|ati' | head -1 || true)

    # Check if AMD is an APU (integrated)
    local amd_is_igpu=false
    if [[ -n "$DETECTED_AMD" ]]; then
        if echo "$DETECTED_AMD" | grep -qiE 'Radeon Graphics$|Ryzen.*Radeon|Renoir|Cezanne|Barcelo|Phoenix|Rembrandt|Lucienne|Mendocino'; then
            amd_is_igpu=true
        fi
    fi

    # Display detected hardware
    gum style --foreground="#89b4fa" "Detected graphics hardware:"
    if [[ -n "$DETECTED_NVIDIA" ]]; then
        echo "  • NVIDIA: $(echo "$DETECTED_NVIDIA" | sed 's/.*: //')"
    fi
    if [[ -n "$DETECTED_INTEL" ]]; then
        echo "  • Intel:  $(echo "$DETECTED_INTEL" | sed 's/.*: //')"
    fi
    if [[ -n "$DETECTED_AMD" ]]; then
        if [[ "$amd_is_igpu" == "true" ]]; then
            echo "  • AMD:    $(echo "$DETECTED_AMD" | sed 's/.*: //') (integrated)"
        else
            echo "  • AMD:    $(echo "$DETECTED_AMD" | sed 's/.*: //') (discrete)"
        fi
    fi
    if [[ -z "$DETECTED_NVIDIA" && -z "$DETECTED_INTEL" && -z "$DETECTED_AMD" ]]; then
        warn "  No recognized GPU detected"
    fi
    echo

    # Build GPU options and determine recommendation
    local gpu_options=()
    local recommended=""

    if [[ -n "$DETECTED_NVIDIA" ]]; then
        # NVIDIA present - check for hybrid
        if [[ -n "$DETECTED_INTEL" || "$amd_is_igpu" == "true" ]]; then
            gpu_options+=("nvidia-setup (hybrid graphics - recommended)")
            recommended="nvidia-setup (hybrid graphics - recommended)"
        else
            gpu_options+=("nvidia-setup (NVIDIA)")
            recommended="nvidia-setup (NVIDIA)"
        fi
    fi

    if [[ -n "$DETECTED_INTEL" && -z "$DETECTED_NVIDIA" ]]; then
        gpu_options+=("intel-setup (Intel)")
        [[ -z "$recommended" ]] && recommended="intel-setup (Intel)"
    fi

    if [[ -n "$DETECTED_AMD" && -z "$DETECTED_NVIDIA" ]]; then
        if [[ "$amd_is_igpu" == "true" ]]; then
            gpu_options+=("amd-setup (AMD integrated)")
        else
            gpu_options+=("amd-setup (AMD discrete)")
        fi
        [[ -z "$recommended" ]] && recommended="${gpu_options[-1]}"
    fi

    # Always add skip option
    gpu_options+=("Skip GPU setup")

    # Show recommendation if we have one
    if [[ -n "$recommended" ]]; then
        success "Recommended: $recommended"
        echo
    fi

    info "Select GPU setup:"
    GPU_SETUP=$(printf '%s\n' "${gpu_options[@]}" | gum choose)

    # Extract just the script name from selection
    case "$GPU_SETUP" in
        nvidia-setup*) GPU_SETUP="nvidia" ;;
        intel-setup*)  GPU_SETUP="intel" ;;
        amd-setup*)    GPU_SETUP="amd" ;;
        *)             GPU_SETUP="skip" ;;
    esac

    echo

    # -------------------------------------------------------------------------
    # Firewall Rules Selection
    # -------------------------------------------------------------------------
    info "Firewall Configuration:"
    echo
    gum style --foreground="#89b4fa" "Select firewall rules to enable (space to select, enter to confirm):"
    echo

    # Use gum choose with --no-limit for multi-select
    FIREWALL_RULES=$(gum choose --no-limit \
        "SSH (port 22)" \
        "HTTP/HTTPS (ports 80, 443)" \
        "KDE Connect / GSConnect (ports 1714-1764)")

    echo
    success "Configuration summary:"
    echo "  GPU Setup:  $GPU_SETUP"
    echo -n "  Firewall:   "
    if [[ -z "$FIREWALL_RULES" ]]; then
        echo "Default deny (no extra rules)"
    else
        echo "$FIREWALL_RULES" | tr '\n' ', ' | sed 's/, $//'
        echo
    fi
    echo

    if ! gum confirm "Proceed with these settings?"; then
        configure_extras
    fi
}

# -----------------------------------------------------------------------------
# Partitioning
# -----------------------------------------------------------------------------

partition_disk() {
    if [[ "$INSTALL_TYPE" == "dualboot" ]]; then
        partition_disk_dualboot
    else
        partition_disk_fresh
    fi
}

partition_disk_fresh() {
    header
    info "Partitioning $DISK..."
    echo

    gum spin --spinner dot --title "Wiping disk..." -- \
        wipefs -af "$DISK"

    gum spin --spinner dot --title "Creating partition table..." -- \
        parted -s "$DISK" mklabel gpt

    gum spin --spinner dot --title "Creating EFI partition (512MB)..." -- \
        parted -s "$DISK" mkpart primary fat32 1MiB 513MiB

    gum spin --spinner dot --title "Setting EFI flags..." -- \
        parted -s "$DISK" set 1 esp on

    gum spin --spinner dot --title "Creating root partition..." -- \
        parted -s "$DISK" mkpart primary btrfs 513MiB 100%

    sleep 1  # Wait for kernel to update partition table

    # Determine partition names (handle nvme vs sd naming)
    if [[ "$DISK" == *"nvme"* ]]; then
        EFI_PART="${DISK}p1"
        ROOT_PART="${DISK}p2"
    else
        EFI_PART="${DISK}1"
        ROOT_PART="${DISK}2"
    fi

    success "Partitioning complete!"
    echo
    lsblk "$DISK"
    sleep 2
}

partition_disk_dualboot() {
    header
    info "Creating Linux partition in unallocated space..."
    echo

    # Use existing EFI partition
    EFI_PART="$EXISTING_EFI_PART"
    info "Using existing EFI partition: $EFI_PART"

    # Create root partition in unallocated space
    # UNALLOCATED_START is already in MB format from parted
    gum spin --spinner dot --title "Creating root partition..." -- \
        parted -s "$DISK" mkpart primary btrfs "$UNALLOCATED_START" 100%

    # Update kernel partition table
    partprobe "$DISK"
    sleep 1

    # Find the newly created partition (last partition on disk)
    # Handles: sda1, nvme0n1p1, mmcblk0p1, vda1
    local last_part_num
    last_part_num=$(lsblk -lno NAME "$DISK" | grep -E '^(sd[a-z]+|nvme[0-9]+n[0-9]+p|mmcblk[0-9]+p|vd[a-z]+)[0-9]+$' | \
                    sed 's/.*[^0-9]//' | sort -n | tail -1)

    # Determine partition naming scheme (with or without 'p' separator)
    if [[ "$DISK" == *"nvme"* ]] || [[ "$DISK" == *"mmcblk"* ]]; then
        ROOT_PART="${DISK}p${last_part_num}"
    else
        ROOT_PART="${DISK}${last_part_num}"
    fi

    success "Created root partition: $ROOT_PART"
    echo
    lsblk "$DISK" -o NAME,SIZE,FSTYPE,LABEL
    sleep 2
}

# -----------------------------------------------------------------------------
# Formatting
# -----------------------------------------------------------------------------

format_partitions() {
    header
    info "Formatting partitions..."
    echo

    # Only format EFI partition for fresh installs
    if [[ "$INSTALL_TYPE" != "dualboot" ]]; then
        info "Formatting EFI partition (FAT32)..."
        mkfs.fat -F32 "$EFI_PART"
    else
        info "Using existing EFI partition (not formatting)"
    fi

    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        info "Setting up LUKS encryption..."
        echo -n "$ENCRYPT_PASSWORD" | cryptsetup luksFormat --type luks2 "$ROOT_PART" -

        info "Opening encrypted container..."
        echo -n "$ENCRYPT_PASSWORD" | cryptsetup open "$ROOT_PART" cryptroot -

        # Store the mapper device for later use
        CRYPT_DEVICE="/dev/mapper/cryptroot"

        info "Formatting encrypted partition (BTRFS)..."
        mkfs.btrfs -f "$CRYPT_DEVICE"
    else
        info "Formatting root partition (BTRFS)..."
        mkfs.btrfs -f "$ROOT_PART"
        CRYPT_DEVICE=""
    fi

    success "Formatting complete!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Mount Partitions
# -----------------------------------------------------------------------------

mount_partitions() {
    header
    info "Mounting partitions..."
    echo

    # Determine which device to mount (encrypted or plain)
    local mount_device
    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        mount_device="$CRYPT_DEVICE"
    else
        mount_device="$ROOT_PART"
    fi

    # Mount root
    mount "$mount_device" /mnt

    # Create BTRFS subvolumes
    info "Creating BTRFS subvolumes..."
    btrfs subvolume create /mnt/@
    btrfs subvolume create /mnt/@home
    btrfs subvolume create /mnt/@snapshots
    btrfs subvolume create /mnt/@var_log
    btrfs subvolume create /mnt/@swap

    # Unmount and remount with subvolumes
    umount /mnt

    mount -o noatime,compress=zstd,space_cache=v2,subvol=@ "$mount_device" /mnt

    mkdir -p /mnt/{boot/efi,home,.snapshots,var/log,swap}

    mount -o noatime,compress=zstd,space_cache=v2,subvol=@home "$mount_device" /mnt/home
    mount -o noatime,compress=zstd,space_cache=v2,subvol=@snapshots "$mount_device" /mnt/.snapshots
    mount -o noatime,compress=zstd,space_cache=v2,subvol=@var_log "$mount_device" /mnt/var/log
    # Swap subvolume: no compression, no copy-on-write
    mount -o noatime,nodatacow,subvol=@swap "$mount_device" /mnt/swap

    mount "$EFI_PART" /mnt/boot/efi

    success "Partitions mounted!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install Base System
# -----------------------------------------------------------------------------

install_base() {
    header
    info "Installing base system..."
    echo

    # Initialize pacman keyring
    info "Initializing pacman keyring..."
    pacman-key --init
    pacman-key --populate archlinux

    # Sync package databases
    info "Syncing package databases..."
    pacman -Sy

    # Pre-configure locale in target before package install
    # Some packages check locale during installation
    info "Pre-configuring locale..."
    mkdir -p /mnt/etc
    echo "$DEFAULT_LOCALE UTF-8" > /mnt/etc/locale.gen
    echo "LANG=$DEFAULT_LOCALE" > /mnt/etc/locale.conf
    echo "KEYMAP=$DEFAULT_KEYMAP" > /mnt/etc/vconsole.conf

    # Read packages from file
    if [[ -f "$PACKAGES_FILE" ]]; then
        mapfile -t packages < <(grep -v '^#' "$PACKAGES_FILE" | grep -v '^$')
    else
        # Fallback to essential packages if file not found
        packages=(base linux linux-firmware grub efibootmgr iwd)
        warn "Package list not found, installing minimal system..."
    fi

    info "Installing ${#packages[@]} packages..."
    info "This will take several minutes..."
    echo

    # Install packages with pacstrap
    pacstrap -K /mnt "${packages[@]}"

    # Verify installation succeeded
    if [[ ! -x /mnt/usr/bin/ln ]]; then
        die "Base system installation failed - coreutils not found!"
    fi

    success "Base system installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Configure System
# -----------------------------------------------------------------------------

configure_system() {
    header
    info "Configuring system..."
    echo

    # Generate fstab
    info "  Generating fstab..."
    genfstab -U /mnt >> /mnt/etc/fstab

    # Copy pacman.conf with multilib enabled
    info "  Copying pacman.conf (multilib enabled)..."
    cp /etc/pacman.conf /mnt/etc/pacman.conf
    cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist

    # Timezone
    info "  Setting timezone..."
    arch-chroot /mnt ln -sf "/usr/share/zoneinfo/$TIMEZONE" /etc/localtime
    arch-chroot /mnt hwclock --systohc

    # Generate locale (config was set before pacstrap)
    info "  Generating locale..."
    arch-chroot /mnt locale-gen

    # Hostname
    info "  Setting hostname..."
    echo "$HOSTNAME" > /mnt/etc/hostname
    cat > /mnt/etc/hosts << EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   $HOSTNAME.localdomain $HOSTNAME
EOF

    # Create user
    info "  Creating user $USERNAME..."
    arch-chroot /mnt useradd -m -G wheel -s "$DEFAULT_SHELL" "$USERNAME"
    echo "$USERNAME:$PASSWORD" | arch-chroot /mnt chpasswd

    # Copy custom Hyprland config to user's home
    info "  Installing Hyprland config..."
    mkdir -p "/mnt/home/$USERNAME/.config/hypr"
    cp /etc/skel/.config/hypr/hyprland.conf "/mnt/home/$USERNAME/.config/hypr/"
    arch-chroot /mnt chown -R "$USERNAME:$USERNAME" "/home/$USERNAME/.config"

    # Configure git for user
    if [[ -n "$GIT_USER_NAME" && -n "$GIT_USER_EMAIL" ]]; then
        info "  Configuring git..."
        arch-chroot /mnt sudo -u "$USERNAME" git config --global user.name "$GIT_USER_NAME"
        arch-chroot /mnt sudo -u "$USERNAME" git config --global user.email "$GIT_USER_EMAIL"
        arch-chroot /mnt sudo -u "$USERNAME" git config --global init.defaultBranch main
    fi

    # Enable sudo for wheel group
    info "  Configuring sudo..."
    sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /mnt/etc/sudoers

    # Configure encryption if enabled
    if [[ "$ENCRYPT_DISK" == "yes" ]]; then
        info "  Configuring disk encryption..."

        # Get UUID of the encrypted partition
        local crypt_uuid
        crypt_uuid=$(blkid -s UUID -o value "$ROOT_PART")

        # Add encrypt hook to mkinitcpio
        sed -i 's/^HOOKS=.*/HOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block encrypt filesystems fsck)/' /mnt/etc/mkinitcpio.conf

        # Configure GRUB for encrypted root
        sed -i "s|^GRUB_CMDLINE_LINUX=\"\"|GRUB_CMDLINE_LINUX=\"cryptdevice=UUID=$crypt_uuid:cryptroot root=/dev/mapper/cryptroot\"|" /mnt/etc/default/grub

        # Enable GRUB cryptodisk support
        echo "GRUB_ENABLE_CRYPTODISK=y" >> /mnt/etc/default/grub

        # Regenerate initramfs
        info "  Regenerating initramfs..."
        arch-chroot /mnt mkinitcpio -P
    fi

    # Configure os-prober for dual-boot
    if [[ "$INSTALL_TYPE" == "dualboot" ]]; then
        info "  Enabling os-prober for Windows detection..."
        echo "GRUB_DISABLE_OS_PROBER=false" >> /mnt/etc/default/grub
    fi

    # Install bootloader
    info "  Installing GRUB bootloader..."
    arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB
    arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg

    # Enable services
    info "  Enabling services..."
    arch-chroot /mnt systemctl enable iwd
    arch-chroot /mnt systemctl enable systemd-resolved
    arch-chroot /mnt systemctl enable sddm

    # Configure iwd with systemd-resolved
    info "  Configuring iwd..."
    mkdir -p /mnt/etc/iwd
    cat > /mnt/etc/iwd/main.conf << 'EOF'
[General]
EnableNetworkConfiguration=true

[Network]
NameResolvingService=systemd
EOF

    # Link resolv.conf to systemd-resolved
    ln -sf /run/systemd/resolve/stub-resolv.conf /mnt/etc/resolv.conf

    # Copy setup scripts to installed system
    info "  Installing setup scripts..."
    for script in nvidia-setup intel-setup amd-setup bluetooth-setup printer-setup firewall-setup dotfiles-setup; do
        if [[ -f "/usr/local/bin/$script" ]]; then
            cp "/usr/local/bin/$script" "/mnt/usr/local/bin/"
            chmod +x "/mnt/usr/local/bin/$script"
        fi
    done

    success "System configured!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Configure Swap
# -----------------------------------------------------------------------------

configure_swap() {
    header
    info "Configuring swap file..."
    echo

    # Get total RAM in MB
    local ram_mb
    ram_mb=$(free -m | awk '/^Mem:/{print $2}')

    # Calculate swap size based on RAM (for hibernate support, match RAM)
    # Best practices:
    #   RAM <= 2GB:  2x RAM
    #   RAM 2-8GB:   Equal to RAM
    #   RAM > 8GB:   Equal to RAM (cap at 16GB for practicality)
    local swap_mb
    if [[ $ram_mb -le 2048 ]]; then
        swap_mb=$((ram_mb * 2))
    elif [[ $ram_mb -gt 16384 ]]; then
        swap_mb=16384  # Cap at 16GB
    else
        swap_mb=$ram_mb
    fi

    local swap_gb=$((swap_mb / 1024))
    info "Detected RAM: ${ram_mb}MB"
    info "Creating swap file: ${swap_gb}GB (${swap_mb}MB)"

    # Create swap file with proper attributes for BTRFS
    # The @swap subvolume is already mounted with nodatacow
    info "  Creating swap file (this may take a moment)..."

    # Use truncate for instant allocation, then chattr for safety
    truncate -s 0 /mnt/swap/swapfile
    chattr +C /mnt/swap/swapfile  # Disable copy-on-write

    # Allocate the actual space
    dd if=/dev/zero of=/mnt/swap/swapfile bs=1M count="$swap_mb" status=progress

    # Set permissions (must be 600)
    chmod 600 /mnt/swap/swapfile

    # Format as swap
    info "  Formatting swap file..."
    mkswap /mnt/swap/swapfile

    # Add to fstab
    info "  Adding swap to fstab..."
    echo "/swap/swapfile none swap defaults 0 0" >> /mnt/etc/fstab

    success "Swap file configured! (${swap_gb}GB)"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install Extra Packages (Bluetooth, Printer, Firewall, GPU)
# -----------------------------------------------------------------------------

install_extras() {
    header
    info "Installing additional system components..."
    echo

    # Set environment variables for chroot-aware scripts
    export CHROOT_TARGET="/mnt"
    export CHROOT_USER="$USERNAME"
    export NONINTERACTIVE="1"

    # Export detected GPU info so scripts don't need to re-detect
    export DETECTED_NVIDIA
    export DETECTED_INTEL
    export DETECTED_AMD

    # -------------------------------------------------------------------------
    # Bluetooth Setup (automatic)
    # -------------------------------------------------------------------------
    info "Setting up Bluetooth..."
    /usr/local/bin/bluetooth-setup
    success "  Bluetooth configured!"
    echo

    # -------------------------------------------------------------------------
    # Printer Setup (automatic)
    # -------------------------------------------------------------------------
    info "Setting up printing (CUPS)..."
    /usr/local/bin/printer-setup
    success "  Printing configured!"
    echo

    # -------------------------------------------------------------------------
    # Firewall Setup (with user-selected rules)
    # -------------------------------------------------------------------------
    info "Setting up firewall (UFW)..."

    # Build firewall args from selected rules
    local firewall_args=""
    if echo "$FIREWALL_RULES" | grep -q "SSH"; then
        firewall_args="$firewall_args --ssh"
    fi
    if echo "$FIREWALL_RULES" | grep -q "HTTP"; then
        firewall_args="$firewall_args --http"
    fi
    if echo "$FIREWALL_RULES" | grep -q "KDE Connect"; then
        firewall_args="$firewall_args --kdeconnect"
    fi

    /usr/local/bin/firewall-setup $firewall_args
    success "  Firewall configured!"
    echo

    # -------------------------------------------------------------------------
    # GPU Setup (based on user selection)
    # -------------------------------------------------------------------------
    if [[ "$GPU_SETUP" != "skip" ]]; then
        info "Setting up GPU drivers ($GPU_SETUP)..."
        echo

        case "$GPU_SETUP" in
            nvidia)
                /usr/local/bin/nvidia-setup
                ;;
            intel)
                /usr/local/bin/intel-setup
                ;;
            amd)
                /usr/local/bin/amd-setup
                ;;
        esac

        success "  GPU drivers configured!"
    else
        info "Skipping GPU setup (can be run later with *-setup scripts)"
    fi

    # Clear environment
    unset CHROOT_TARGET CHROOT_USER NONINTERACTIVE

    echo
    success "Additional components installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Install AUR Packages
# -----------------------------------------------------------------------------

install_aur_packages() {
    header
    info "Installing AUR packages..."
    echo

    # Read AUR packages from config file (excluding comments and blank lines)
    local aur_packages_file="/root/aur-packages.x86_64"
    local aur_packages=()

    if [[ ! -f "$aur_packages_file" ]]; then
        warn "AUR packages file not found: $aur_packages_file"
        warn "Skipping AUR package installation"
        return 0
    fi

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and blank lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        aur_packages+=("$line")
    done < "$aur_packages_file"

    if [[ ${#aur_packages[@]} -eq 0 ]]; then
        info "No AUR packages to install"
        return 0
    fi

    info "Packages to install: ${aur_packages[*]}"
    echo

    # Use user's home directory (guaranteed to exist after useradd -m)
    local script_path="/mnt/home/$USERNAME/install-aur.sh"

    # Create a script to run as the user for AUR installation
    cat > "$script_path" << AURSCRIPT
#!/bin/bash
set -e

cd ~

# Install yay
if ! command -v yay &>/dev/null; then
    git clone https://aur.archlinux.org/yay-bin.git
    cd yay-bin
    makepkg -si --noconfirm
    cd ..
    rm -rf yay-bin
fi

# Install AUR packages
yay -S --noconfirm ${aur_packages[*]}
AURSCRIPT

    chown "$USERNAME:$USERNAME" "$script_path" 2>/dev/null || true
    chmod +x "$script_path"

    # Verify script exists
    if [[ ! -f "$script_path" ]]; then
        die "Failed to create AUR install script!"
    fi

    info "Building and installing yay (AUR helper)..."
    arch-chroot /mnt sudo -u "$USERNAME" bash "/home/$USERNAME/install-aur.sh"

    # Cleanup
    rm -f "$script_path"

    success "AUR packages installed!"
    sleep 1
}

# -----------------------------------------------------------------------------
# Finish Installation
# -----------------------------------------------------------------------------

finish() {
    header

    gum style \
        --border rounded \
        --border-foreground="#a6e3a1" \
        --padding "1 2" \
        --margin "1" \
        --align center \
        "Installation Complete"

    echo
    gum style \
        --padding "0 2" \
        "Your new Hyprland system is ready!" \
        "" \
        "Next steps:" \
        "  1. Reboot into your new system" \
        "  2. Log in with username: $USERNAME" \
        "  3. Hyprland will start automatically via SDDM" \
        "" \
        "Useful keybinds (defaults):" \
        "  SUPER + Enter    → Open terminal (Ghostty)" \
        "  SUPER + D        → Application launcher (Walker)" \
        "  SUPER + Q        → Close window" \
        "  SUPER + 1-9      → Switch workspace"

    echo
    if gum confirm "Reboot now?"; then
        umount -R /mnt
        reboot
    else
        info "You can reboot manually when ready."
        info "Run 'umount -R /mnt' before rebooting."
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        die "This script must be run as root!"
    fi

    # Check for required tools
    if ! command -v gum &>/dev/null; then
        die "gum is not installed!"
    fi

    welcome
    select_install_type
    select_disk
    configure_user
    configure_extras
    partition_disk
    format_partitions
    mount_partitions
    check_network
    install_base
    configure_system
    configure_swap
    install_extras
    install_aur_packages
    finish
}

main "$@"
